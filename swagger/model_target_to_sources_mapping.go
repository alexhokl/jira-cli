/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the TargetToSourcesMapping type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TargetToSourcesMapping{}

// TargetToSourcesMapping An object representing the mapping of issues and data related to destination entities, like fields and statuses, that are required during a bulk move.
type TargetToSourcesMapping struct {
	// If `true`, when issues are moved into this target group, they will adopt the target project's default classification, if they don't have a classification already. If they do have a classification, it will be kept the same even after the move. Leave `targetClassification` empty when using this.  If `false`, you must provide a `targetClassification` mapping for each classification associated with the selected issues.  [Benefit from data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
	InferClassificationDefaults bool `json:"inferClassificationDefaults"`
	// If `true`, values from the source issues will be retained for the mandatory fields in the field configuration of the destination project. The `targetMandatoryFields` property shouldn't be defined.  If `false`, the user is required to set values for mandatory fields present in the field configuration of the destination project. Provide input by defining the `targetMandatoryFields` property
	InferFieldDefaults bool `json:"inferFieldDefaults"`
	// If `true`, the statuses of issues being moved in this target group that are not present in the target workflow will be changed to the default status of the target workflow (see below). Leave `targetStatus` empty when using this.  If `false`, you must provide a `targetStatus` for each status not present in the target workflow.  The default status in a workflow is referred to as the \"initial status\". Each workflow has its own unique initial status. When an issue is created, it is automatically assigned to this initial status. Read more about configuring initial statuses: [Configure the initial status | Atlassian Support.](https://support.atlassian.com/jira-cloud-administration/docs/configure-the-initial-status/)
	InferStatusDefaults bool `json:"inferStatusDefaults"`
	// When an issue is moved, its subtasks (if there are any) need to be moved with it. `inferSubtaskTypeDefault` helps with moving the subtasks by picking a random subtask type in the target project.  If `true`, subtasks will automatically move to the same project as their parent.  When they move:   *  Their `issueType` will be set to the default for subtasks in the target project.  *  Values for mandatory fields will be retained from the source issues  *  Specifying separate mapping for implicit subtasks wonâ€™t be allowed.  If `false`, you must manually move the subtasks. They will retain the parent which they had in the current project after being moved.
	InferSubtaskTypeDefault bool `json:"inferSubtaskTypeDefault"`
	// List of issue IDs or keys to be moved.
	IssueIdsOrKeys []string `json:"issueIdsOrKeys,omitempty"`
	// List of the objects containing classifications in the source issues and their new values which need to be set during the bulk move operation.  It is mandatory to provide source classification to target classification mapping when the source classification is invalid for the target project and issue type.   *  **You should only define this property when `inferClassificationDefaults` is `false`.**  *  **In order to provide mapping for issues which don't have a classification, use `\"-1\"`.**
	TargetClassification []TargetClassification `json:"targetClassification,omitempty"`
	// List of objects containing mandatory fields in the target field configuration and new values that need to be set during the bulk move operation.  The new values will only be applied if the field is mandatory in the target project and at least one issue from the source has that field empty, or if the field context is different in the target project (e.g. project-scoped version fields).  **You should only define this property when `inferFieldDefaults` is `false`.**
	TargetMandatoryFields []TargetMandatoryFields `json:"targetMandatoryFields,omitempty"`
	// List of the objects containing statuses in the source workflow and their new values which need to be set during the bulk move operation.  The new values will only be applied if the source status is invalid for the target project and issue type.  It is mandatory to provide source status to target status mapping when the source status is invalid for the target project and issue type.  **You should only define this property when `inferStatusDefaults` is `false`.**
	TargetStatus []TargetStatus `json:"targetStatus,omitempty"`
}

type _TargetToSourcesMapping TargetToSourcesMapping

// NewTargetToSourcesMapping instantiates a new TargetToSourcesMapping object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTargetToSourcesMapping(inferClassificationDefaults bool, inferFieldDefaults bool, inferStatusDefaults bool, inferSubtaskTypeDefault bool) *TargetToSourcesMapping {
	this := TargetToSourcesMapping{}
	this.InferClassificationDefaults = inferClassificationDefaults
	this.InferFieldDefaults = inferFieldDefaults
	this.InferStatusDefaults = inferStatusDefaults
	this.InferSubtaskTypeDefault = inferSubtaskTypeDefault
	return &this
}

// NewTargetToSourcesMappingWithDefaults instantiates a new TargetToSourcesMapping object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTargetToSourcesMappingWithDefaults() *TargetToSourcesMapping {
	this := TargetToSourcesMapping{}
	return &this
}

// GetInferClassificationDefaults returns the InferClassificationDefaults field value
func (o *TargetToSourcesMapping) GetInferClassificationDefaults() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.InferClassificationDefaults
}

// GetInferClassificationDefaultsOk returns a tuple with the InferClassificationDefaults field value
// and a boolean to check if the value has been set.
func (o *TargetToSourcesMapping) GetInferClassificationDefaultsOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.InferClassificationDefaults, true
}

// SetInferClassificationDefaults sets field value
func (o *TargetToSourcesMapping) SetInferClassificationDefaults(v bool) {
	o.InferClassificationDefaults = v
}

// GetInferFieldDefaults returns the InferFieldDefaults field value
func (o *TargetToSourcesMapping) GetInferFieldDefaults() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.InferFieldDefaults
}

// GetInferFieldDefaultsOk returns a tuple with the InferFieldDefaults field value
// and a boolean to check if the value has been set.
func (o *TargetToSourcesMapping) GetInferFieldDefaultsOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.InferFieldDefaults, true
}

// SetInferFieldDefaults sets field value
func (o *TargetToSourcesMapping) SetInferFieldDefaults(v bool) {
	o.InferFieldDefaults = v
}

// GetInferStatusDefaults returns the InferStatusDefaults field value
func (o *TargetToSourcesMapping) GetInferStatusDefaults() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.InferStatusDefaults
}

// GetInferStatusDefaultsOk returns a tuple with the InferStatusDefaults field value
// and a boolean to check if the value has been set.
func (o *TargetToSourcesMapping) GetInferStatusDefaultsOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.InferStatusDefaults, true
}

// SetInferStatusDefaults sets field value
func (o *TargetToSourcesMapping) SetInferStatusDefaults(v bool) {
	o.InferStatusDefaults = v
}

// GetInferSubtaskTypeDefault returns the InferSubtaskTypeDefault field value
func (o *TargetToSourcesMapping) GetInferSubtaskTypeDefault() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.InferSubtaskTypeDefault
}

// GetInferSubtaskTypeDefaultOk returns a tuple with the InferSubtaskTypeDefault field value
// and a boolean to check if the value has been set.
func (o *TargetToSourcesMapping) GetInferSubtaskTypeDefaultOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.InferSubtaskTypeDefault, true
}

// SetInferSubtaskTypeDefault sets field value
func (o *TargetToSourcesMapping) SetInferSubtaskTypeDefault(v bool) {
	o.InferSubtaskTypeDefault = v
}

// GetIssueIdsOrKeys returns the IssueIdsOrKeys field value if set, zero value otherwise.
func (o *TargetToSourcesMapping) GetIssueIdsOrKeys() []string {
	if o == nil || IsNil(o.IssueIdsOrKeys) {
		var ret []string
		return ret
	}
	return o.IssueIdsOrKeys
}

// GetIssueIdsOrKeysOk returns a tuple with the IssueIdsOrKeys field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TargetToSourcesMapping) GetIssueIdsOrKeysOk() ([]string, bool) {
	if o == nil || IsNil(o.IssueIdsOrKeys) {
		return nil, false
	}
	return o.IssueIdsOrKeys, true
}

// HasIssueIdsOrKeys returns a boolean if a field has been set.
func (o *TargetToSourcesMapping) HasIssueIdsOrKeys() bool {
	if o != nil && !IsNil(o.IssueIdsOrKeys) {
		return true
	}

	return false
}

// SetIssueIdsOrKeys gets a reference to the given []string and assigns it to the IssueIdsOrKeys field.
func (o *TargetToSourcesMapping) SetIssueIdsOrKeys(v []string) {
	o.IssueIdsOrKeys = v
}

// GetTargetClassification returns the TargetClassification field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *TargetToSourcesMapping) GetTargetClassification() []TargetClassification {
	if o == nil {
		var ret []TargetClassification
		return ret
	}
	return o.TargetClassification
}

// GetTargetClassificationOk returns a tuple with the TargetClassification field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *TargetToSourcesMapping) GetTargetClassificationOk() ([]TargetClassification, bool) {
	if o == nil || IsNil(o.TargetClassification) {
		return nil, false
	}
	return o.TargetClassification, true
}

// HasTargetClassification returns a boolean if a field has been set.
func (o *TargetToSourcesMapping) HasTargetClassification() bool {
	if o != nil && !IsNil(o.TargetClassification) {
		return true
	}

	return false
}

// SetTargetClassification gets a reference to the given []TargetClassification and assigns it to the TargetClassification field.
func (o *TargetToSourcesMapping) SetTargetClassification(v []TargetClassification) {
	o.TargetClassification = v
}

// GetTargetMandatoryFields returns the TargetMandatoryFields field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *TargetToSourcesMapping) GetTargetMandatoryFields() []TargetMandatoryFields {
	if o == nil {
		var ret []TargetMandatoryFields
		return ret
	}
	return o.TargetMandatoryFields
}

// GetTargetMandatoryFieldsOk returns a tuple with the TargetMandatoryFields field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *TargetToSourcesMapping) GetTargetMandatoryFieldsOk() ([]TargetMandatoryFields, bool) {
	if o == nil || IsNil(o.TargetMandatoryFields) {
		return nil, false
	}
	return o.TargetMandatoryFields, true
}

// HasTargetMandatoryFields returns a boolean if a field has been set.
func (o *TargetToSourcesMapping) HasTargetMandatoryFields() bool {
	if o != nil && !IsNil(o.TargetMandatoryFields) {
		return true
	}

	return false
}

// SetTargetMandatoryFields gets a reference to the given []TargetMandatoryFields and assigns it to the TargetMandatoryFields field.
func (o *TargetToSourcesMapping) SetTargetMandatoryFields(v []TargetMandatoryFields) {
	o.TargetMandatoryFields = v
}

// GetTargetStatus returns the TargetStatus field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *TargetToSourcesMapping) GetTargetStatus() []TargetStatus {
	if o == nil {
		var ret []TargetStatus
		return ret
	}
	return o.TargetStatus
}

// GetTargetStatusOk returns a tuple with the TargetStatus field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *TargetToSourcesMapping) GetTargetStatusOk() ([]TargetStatus, bool) {
	if o == nil || IsNil(o.TargetStatus) {
		return nil, false
	}
	return o.TargetStatus, true
}

// HasTargetStatus returns a boolean if a field has been set.
func (o *TargetToSourcesMapping) HasTargetStatus() bool {
	if o != nil && !IsNil(o.TargetStatus) {
		return true
	}

	return false
}

// SetTargetStatus gets a reference to the given []TargetStatus and assigns it to the TargetStatus field.
func (o *TargetToSourcesMapping) SetTargetStatus(v []TargetStatus) {
	o.TargetStatus = v
}

func (o TargetToSourcesMapping) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TargetToSourcesMapping) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["inferClassificationDefaults"] = o.InferClassificationDefaults
	toSerialize["inferFieldDefaults"] = o.InferFieldDefaults
	toSerialize["inferStatusDefaults"] = o.InferStatusDefaults
	toSerialize["inferSubtaskTypeDefault"] = o.InferSubtaskTypeDefault
	if !IsNil(o.IssueIdsOrKeys) {
		toSerialize["issueIdsOrKeys"] = o.IssueIdsOrKeys
	}
	if o.TargetClassification != nil {
		toSerialize["targetClassification"] = o.TargetClassification
	}
	if o.TargetMandatoryFields != nil {
		toSerialize["targetMandatoryFields"] = o.TargetMandatoryFields
	}
	if o.TargetStatus != nil {
		toSerialize["targetStatus"] = o.TargetStatus
	}
	return toSerialize, nil
}

func (o *TargetToSourcesMapping) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"inferClassificationDefaults",
		"inferFieldDefaults",
		"inferStatusDefaults",
		"inferSubtaskTypeDefault",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varTargetToSourcesMapping := _TargetToSourcesMapping{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varTargetToSourcesMapping)

	if err != nil {
		return err
	}

	*o = TargetToSourcesMapping(varTargetToSourcesMapping)

	return err
}

type NullableTargetToSourcesMapping struct {
	value *TargetToSourcesMapping
	isSet bool
}

func (v NullableTargetToSourcesMapping) Get() *TargetToSourcesMapping {
	return v.value
}

func (v *NullableTargetToSourcesMapping) Set(val *TargetToSourcesMapping) {
	v.value = val
	v.isSet = true
}

func (v NullableTargetToSourcesMapping) IsSet() bool {
	return v.isSet
}

func (v *NullableTargetToSourcesMapping) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTargetToSourcesMapping(val *TargetToSourcesMapping) *NullableTargetToSourcesMapping {
	return &NullableTargetToSourcesMapping{value: val, isSet: true}
}

func (v NullableTargetToSourcesMapping) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTargetToSourcesMapping) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


