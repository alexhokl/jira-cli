/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiGetWorklogsByIssueIdAndWorklogIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	bulkWorklogKeyRequestBean *BulkWorklogKeyRequestBean
}

// A JSON object containing a list of issue ID and worklog ID pairs.
func (r ApiGetWorklogsByIssueIdAndWorklogIdRequest) BulkWorklogKeyRequestBean(bulkWorklogKeyRequestBean BulkWorklogKeyRequestBean) ApiGetWorklogsByIssueIdAndWorklogIdRequest {
	r.bulkWorklogKeyRequestBean = &bulkWorklogKeyRequestBean
	return r
}

func (r ApiGetWorklogsByIssueIdAndWorklogIdRequest) Execute() (*BulkWorklogKeyResponseBean, *http.Response, error) {
	return r.ApiService.GetWorklogsByIssueIdAndWorklogIdExecute(r)
}

/*
GetWorklogsByIssueIdAndWorklogId Get worklogs by issue id and worklog id

Returns worklog details for a list of issue ID and worklog ID pairs.

This is an internal API for bulk fetching worklogs by their issue and worklog IDs. Worklogs that don't exist will be filtered out from the response.

The returned list of worklogs is limited to 1000 items.

**[Permissions](#permissions) required:** This is an internal service-to-service API that requires ASAP authentication. No user permission checks are performed as this bypasses normal user context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWorklogsByIssueIdAndWorklogIdRequest
*/
func (a *DefaultAPIService) GetWorklogsByIssueIdAndWorklogId(ctx context.Context) ApiGetWorklogsByIssueIdAndWorklogIdRequest {
	return ApiGetWorklogsByIssueIdAndWorklogIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkWorklogKeyResponseBean
func (a *DefaultAPIService) GetWorklogsByIssueIdAndWorklogIdExecute(r ApiGetWorklogsByIssueIdAndWorklogIdRequest) (*BulkWorklogKeyResponseBean, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkWorklogKeyResponseBean
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetWorklogsByIssueIdAndWorklogId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/internal/api/latest/worklog/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWorklogKeyRequestBean == nil {
		return localVarReturnValue, nil, reportError("bulkWorklogKeyRequestBean is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWorklogKeyRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
