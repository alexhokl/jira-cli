/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// IssueCustomFieldValuesAppsAPIService IssueCustomFieldValuesAppsAPI service
type IssueCustomFieldValuesAppsAPIService service

type ApiUpdateCustomFieldValueRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldValuesAppsAPIService
	fieldIdOrKey string
	customFieldValueUpdateDetails *CustomFieldValueUpdateDetails
	generateChangelog *bool
}

func (r ApiUpdateCustomFieldValueRequest) CustomFieldValueUpdateDetails(customFieldValueUpdateDetails CustomFieldValueUpdateDetails) ApiUpdateCustomFieldValueRequest {
	r.customFieldValueUpdateDetails = &customFieldValueUpdateDetails
	return r
}

// Whether to generate a changelog for this update.
func (r ApiUpdateCustomFieldValueRequest) GenerateChangelog(generateChangelog bool) ApiUpdateCustomFieldValueRequest {
	r.generateChangelog = &generateChangelog
	return r
}

func (r ApiUpdateCustomFieldValueRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateCustomFieldValueExecute(r)
}

/*
UpdateCustomFieldValue Update custom field value

Updates the value of a custom field on one or more issues.

Apps can only perform this operation on [custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/) and [custom field types](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field-type/) declared in their own manifests.

**[Permissions](#permissions) required:** Only the app that owns the custom field or custom field type can update its values with this operation.

The new `write:app-data:jira` OAuth scope is 100% optional now, and not using it won't break your app. However, we recommend adding it to your app's scope list because we will eventually make it mandatory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldIdOrKey The ID or key of the custom field. For example, `customfield_10010`.
 @return ApiUpdateCustomFieldValueRequest
*/
func (a *IssueCustomFieldValuesAppsAPIService) UpdateCustomFieldValue(ctx context.Context, fieldIdOrKey string) ApiUpdateCustomFieldValueRequest {
	return ApiUpdateCustomFieldValueRequest{
		ApiService: a,
		ctx: ctx,
		fieldIdOrKey: fieldIdOrKey,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueCustomFieldValuesAppsAPIService) UpdateCustomFieldValueExecute(r ApiUpdateCustomFieldValueRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldValuesAppsAPIService.UpdateCustomFieldValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/app/field/{fieldIdOrKey}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldIdOrKey"+"}", url.PathEscape(parameterValueToString(r.fieldIdOrKey, "fieldIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customFieldValueUpdateDetails == nil {
		return localVarReturnValue, nil, reportError("customFieldValueUpdateDetails is required and must be specified")
	}

	if r.generateChangelog != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateChangelog", r.generateChangelog, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateChangelog", defaultValue, "form", "")
		r.generateChangelog = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customFieldValueUpdateDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMultipleCustomFieldValuesRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldValuesAppsAPIService
	multipleCustomFieldValuesUpdateDetails *MultipleCustomFieldValuesUpdateDetails
	generateChangelog *bool
}

func (r ApiUpdateMultipleCustomFieldValuesRequest) MultipleCustomFieldValuesUpdateDetails(multipleCustomFieldValuesUpdateDetails MultipleCustomFieldValuesUpdateDetails) ApiUpdateMultipleCustomFieldValuesRequest {
	r.multipleCustomFieldValuesUpdateDetails = &multipleCustomFieldValuesUpdateDetails
	return r
}

// Whether to generate a changelog for this update.
func (r ApiUpdateMultipleCustomFieldValuesRequest) GenerateChangelog(generateChangelog bool) ApiUpdateMultipleCustomFieldValuesRequest {
	r.generateChangelog = &generateChangelog
	return r
}

func (r ApiUpdateMultipleCustomFieldValuesRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateMultipleCustomFieldValuesExecute(r)
}

/*
UpdateMultipleCustomFieldValues Update custom fields

Updates the value of one or more custom fields on one or more issues. Combinations of custom field and issue should be unique within the request.

Apps can only perform this operation on [custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/) and [custom field types](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field-type/) declared in their own manifests.

**[Permissions](#permissions) required:** Only the app that owns the custom field or custom field type can update its values with this operation.

The new `write:app-data:jira` OAuth scope is 100% optional now, and not using it won't break your app. However, we recommend adding it to your app's scope list because we will eventually make it mandatory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateMultipleCustomFieldValuesRequest
*/
func (a *IssueCustomFieldValuesAppsAPIService) UpdateMultipleCustomFieldValues(ctx context.Context) ApiUpdateMultipleCustomFieldValuesRequest {
	return ApiUpdateMultipleCustomFieldValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueCustomFieldValuesAppsAPIService) UpdateMultipleCustomFieldValuesExecute(r ApiUpdateMultipleCustomFieldValuesRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldValuesAppsAPIService.UpdateMultipleCustomFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/app/field/value"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multipleCustomFieldValuesUpdateDetails == nil {
		return localVarReturnValue, nil, reportError("multipleCustomFieldValuesUpdateDetails is required and must be specified")
	}

	if r.generateChangelog != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateChangelog", r.generateChangelog, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateChangelog", defaultValue, "form", "")
		r.generateChangelog = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.multipleCustomFieldValuesUpdateDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
