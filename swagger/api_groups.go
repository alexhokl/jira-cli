/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// GroupsAPIService GroupsAPI service
type GroupsAPIService service

type ApiAddUserToGroupRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	updateUserToGroupBean *UpdateUserToGroupBean
	groupname *string
	groupId *string
}

// The user to add to the group.
func (r ApiAddUserToGroupRequest) UpdateUserToGroupBean(updateUserToGroupBean UpdateUserToGroupBean) ApiAddUserToGroupRequest {
	r.updateUserToGroupBean = &updateUserToGroupBean
	return r
}

// As a group&#39;s name can change, use of &#x60;groupId&#x60; is recommended to identify a group.   The name of the group. This parameter cannot be used with the &#x60;groupId&#x60; parameter.
func (r ApiAddUserToGroupRequest) Groupname(groupname string) ApiAddUserToGroupRequest {
	r.groupname = &groupname
	return r
}

// The ID of the group. This parameter cannot be used with the &#x60;groupName&#x60; parameter.
func (r ApiAddUserToGroupRequest) GroupId(groupId string) ApiAddUserToGroupRequest {
	r.groupId = &groupId
	return r
}

func (r ApiAddUserToGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.AddUserToGroupExecute(r)
}

/*
AddUserToGroup Add user to group

Adds a user to a group.

**[Permissions](#permissions) required:** Site administration (that is, member of the *site-admin* [group](https://confluence.atlassian.com/x/24xjL)).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddUserToGroupRequest
*/
func (a *GroupsAPIService) AddUserToGroup(ctx context.Context) ApiAddUserToGroupRequest {
	return ApiAddUserToGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *GroupsAPIService) AddUserToGroupExecute(r ApiAddUserToGroupRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AddUserToGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateUserToGroupBean == nil {
		return localVarReturnValue, nil, reportError("updateUserToGroupBean is required and must be specified")
	}

	if r.groupname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupname", r.groupname, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateUserToGroupBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	startAt *int64
	maxResults *int32
	groupId *[]string
	groupName *[]string
	accessType *string
	applicationKey *string
}

// The index of the first item to return in a page of results (page offset).
func (r ApiBulkGetGroupsRequest) StartAt(startAt int64) ApiBulkGetGroupsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiBulkGetGroupsRequest) MaxResults(maxResults int32) ApiBulkGetGroupsRequest {
	r.maxResults = &maxResults
	return r
}

// The ID of a group. To specify multiple IDs, pass multiple &#x60;groupId&#x60; parameters. For example, &#x60;groupId&#x3D;5b10a2844c20165700ede21g&amp;groupId&#x3D;5b10ac8d82e05b22cc7d4ef5&#x60;.
func (r ApiBulkGetGroupsRequest) GroupId(groupId []string) ApiBulkGetGroupsRequest {
	r.groupId = &groupId
	return r
}

// The name of a group. To specify multiple names, pass multiple &#x60;groupName&#x60; parameters. For example, &#x60;groupName&#x3D;administrators&amp;groupName&#x3D;jira-software-users&#x60;.
func (r ApiBulkGetGroupsRequest) GroupName(groupName []string) ApiBulkGetGroupsRequest {
	r.groupName = &groupName
	return r
}

// The access level of a group. Valid values: &#39;site-admin&#39;, &#39;admin&#39;, &#39;user&#39;.
func (r ApiBulkGetGroupsRequest) AccessType(accessType string) ApiBulkGetGroupsRequest {
	r.accessType = &accessType
	return r
}

// The application key of the product user groups to search for. Valid values: &#39;jira-servicedesk&#39;, &#39;jira-software&#39;, &#39;jira-product-discovery&#39;, &#39;jira-core&#39;.
func (r ApiBulkGetGroupsRequest) ApplicationKey(applicationKey string) ApiBulkGetGroupsRequest {
	r.applicationKey = &applicationKey
	return r
}

func (r ApiBulkGetGroupsRequest) Execute() (*PageBeanGroupDetails, *http.Response, error) {
	return r.ApiService.BulkGetGroupsExecute(r)
}

/*
BulkGetGroups Bulk get groups

Returns a [paginated](#pagination) list of groups.

**[Permissions](#permissions) required:** *Browse users and groups* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkGetGroupsRequest
*/
func (a *GroupsAPIService) BulkGetGroups(ctx context.Context) ApiBulkGetGroupsRequest {
	return ApiBulkGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanGroupDetails
func (a *GroupsAPIService) BulkGetGroupsExecute(r ApiBulkGetGroupsRequest) (*PageBeanGroupDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanGroupDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.BulkGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", t, "form", "multi")
		}
	}
	if r.groupName != nil {
		t := *r.groupName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupName", t, "form", "multi")
		}
	}
	if r.accessType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessType", r.accessType, "form", "")
	}
	if r.applicationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationKey", r.applicationKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGroupRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	addGroupBean *AddGroupBean
}

// The name of the group.
func (r ApiCreateGroupRequest) AddGroupBean(addGroupBean AddGroupBean) ApiCreateGroupRequest {
	r.addGroupBean = &addGroupBean
	return r
}

func (r ApiCreateGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup Create group

Creates a group.

**[Permissions](#permissions) required:** Site administration (that is, member of the *site-admin* [group](https://confluence.atlassian.com/x/24xjL)).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGroupRequest
*/
func (a *GroupsAPIService) CreateGroup(ctx context.Context) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *GroupsAPIService) CreateGroupExecute(r ApiCreateGroupRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.CreateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addGroupBean == nil {
		return localVarReturnValue, nil, reportError("addGroupBean is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addGroupBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	accountId *string
	query *string
	exclude *[]string
	excludeId *[]string
	maxResults *int32
	caseInsensitive *bool
	userName *string
}

// This parameter is deprecated, setting it does not affect the results. To find groups containing a particular user, use [Get user groups](#api-rest-api-3-user-groups-get).
func (r ApiFindGroupsRequest) AccountId(accountId string) ApiFindGroupsRequest {
	r.accountId = &accountId
	return r
}

// The string to find in group names.
func (r ApiFindGroupsRequest) Query(query string) ApiFindGroupsRequest {
	r.query = &query
	return r
}

// As a group&#39;s name can change, use of &#x60;excludeGroupIds&#x60; is recommended to identify a group.   A group to exclude from the result. To exclude multiple groups, provide an ampersand-separated list. For example, &#x60;exclude&#x3D;group1&amp;exclude&#x3D;group2&#x60;. This parameter cannot be used with the &#x60;excludeGroupIds&#x60; parameter.
func (r ApiFindGroupsRequest) Exclude(exclude []string) ApiFindGroupsRequest {
	r.exclude = &exclude
	return r
}

// A group ID to exclude from the result. To exclude multiple groups, provide an ampersand-separated list. For example, &#x60;excludeId&#x3D;group1-id&amp;excludeId&#x3D;group2-id&#x60;. This parameter cannot be used with the &#x60;excludeGroups&#x60; parameter.
func (r ApiFindGroupsRequest) ExcludeId(excludeId []string) ApiFindGroupsRequest {
	r.excludeId = &excludeId
	return r
}

// The maximum number of groups to return. The maximum number of groups that can be returned is limited by the system property &#x60;jira.ajax.autocomplete.limit&#x60;.
func (r ApiFindGroupsRequest) MaxResults(maxResults int32) ApiFindGroupsRequest {
	r.maxResults = &maxResults
	return r
}

// Whether the search for groups should be case insensitive.
func (r ApiFindGroupsRequest) CaseInsensitive(caseInsensitive bool) ApiFindGroupsRequest {
	r.caseInsensitive = &caseInsensitive
	return r
}

// This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
func (r ApiFindGroupsRequest) UserName(userName string) ApiFindGroupsRequest {
	r.userName = &userName
	return r
}

func (r ApiFindGroupsRequest) Execute() (*FoundGroups, *http.Response, error) {
	return r.ApiService.FindGroupsExecute(r)
}

/*
FindGroups Find groups

Returns a list of groups whose names contain a query string. A list of group names can be provided to exclude groups from the results.

The primary use case for this resource is to populate a group picker suggestions list. To this end, the returned object includes the `html` field where the matched query term is highlighted in the group name with the HTML strong tag. Also, the groups list is wrapped in a response object that contains a header for use in the picker, specifically *Showing X of Y matching groups*.

The list returns with the groups sorted. If no groups match the list criteria, an empty list is returned.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg). Anonymous calls and calls by users without the required permission return an empty list.

*Browse users and groups* [global permission](https://confluence.atlassian.com/x/x4dKLg). Without this permission, calls where query is not an exact match to an existing group will return an empty list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindGroupsRequest
*/
func (a *GroupsAPIService) FindGroups(ctx context.Context) ApiFindGroupsRequest {
	return ApiFindGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FoundGroups
func (a *GroupsAPIService) FindGroupsExecute(r ApiFindGroupsRequest) (*FoundGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FoundGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.FindGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/groups/picker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.exclude != nil {
		t := *r.exclude
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", t, "form", "multi")
		}
	}
	if r.excludeId != nil {
		t := *r.excludeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeId", t, "form", "multi")
		}
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.caseInsensitive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInsensitive", r.caseInsensitive, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInsensitive", defaultValue, "form", "")
		r.caseInsensitive = &defaultValue
	}
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	groupname *string
	groupId *string
	expand *string
}

// As a group&#39;s name can change, use of &#x60;groupId&#x60; is recommended to identify a group.   The name of the group. This parameter cannot be used with the &#x60;groupId&#x60; parameter.
func (r ApiGetGroupRequest) Groupname(groupname string) ApiGetGroupRequest {
	r.groupname = &groupname
	return r
}

// The ID of the group. This parameter cannot be used with the &#x60;groupName&#x60; parameter.
func (r ApiGetGroupRequest) GroupId(groupId string) ApiGetGroupRequest {
	r.groupId = &groupId
	return r
}

// List of fields to expand.
func (r ApiGetGroupRequest) Expand(expand string) ApiGetGroupRequest {
	r.expand = &expand
	return r
}

func (r ApiGetGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup Get group

This operation is deprecated, use [`group/member`](#api-rest-api-3-group-member-get).

Returns all users in a group.

**[Permissions](#permissions) required:** either of:

 *  *Browse users and groups* [global permission](https://confluence.atlassian.com/x/x4dKLg).
 *  *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupRequest

Deprecated
*/
func (a *GroupsAPIService) GetGroup(ctx context.Context) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Group
// Deprecated
func (a *GroupsAPIService) GetGroupExecute(r ApiGetGroupRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.GetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupname", r.groupname, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersFromGroupRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	groupname *string
	groupId *string
	includeInactiveUsers *bool
	startAt *int64
	maxResults *int32
}

// As a group&#39;s name can change, use of &#x60;groupId&#x60; is recommended to identify a group.   The name of the group. This parameter cannot be used with the &#x60;groupId&#x60; parameter.
func (r ApiGetUsersFromGroupRequest) Groupname(groupname string) ApiGetUsersFromGroupRequest {
	r.groupname = &groupname
	return r
}

// The ID of the group. This parameter cannot be used with the &#x60;groupName&#x60; parameter.
func (r ApiGetUsersFromGroupRequest) GroupId(groupId string) ApiGetUsersFromGroupRequest {
	r.groupId = &groupId
	return r
}

// Include inactive users.
func (r ApiGetUsersFromGroupRequest) IncludeInactiveUsers(includeInactiveUsers bool) ApiGetUsersFromGroupRequest {
	r.includeInactiveUsers = &includeInactiveUsers
	return r
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetUsersFromGroupRequest) StartAt(startAt int64) ApiGetUsersFromGroupRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page (number should be between 1 and 50).
func (r ApiGetUsersFromGroupRequest) MaxResults(maxResults int32) ApiGetUsersFromGroupRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetUsersFromGroupRequest) Execute() (*PageBeanUserDetails, *http.Response, error) {
	return r.ApiService.GetUsersFromGroupExecute(r)
}

/*
GetUsersFromGroup Get users from group

Returns a [paginated](#pagination) list of all users in a group.

Note that users are ordered by username, however the username is not returned in the results due to privacy reasons.

**[Permissions](#permissions) required:** either of:

 *  *Browse users and groups* [global permission](https://confluence.atlassian.com/x/x4dKLg).
 *  *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersFromGroupRequest
*/
func (a *GroupsAPIService) GetUsersFromGroup(ctx context.Context) ApiGetUsersFromGroupRequest {
	return ApiGetUsersFromGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanUserDetails
func (a *GroupsAPIService) GetUsersFromGroupExecute(r ApiGetUsersFromGroupRequest) (*PageBeanUserDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanUserDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.GetUsersFromGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group/member"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupname", r.groupname, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.includeInactiveUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveUsers", r.includeInactiveUsers, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveUsers", defaultValue, "form", "")
		r.includeInactiveUsers = &defaultValue
	}
	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveGroupRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	groupname *string
	groupId *string
	swapGroup *string
	swapGroupId *string
}

func (r ApiRemoveGroupRequest) Groupname(groupname string) ApiRemoveGroupRequest {
	r.groupname = &groupname
	return r
}

// The ID of the group. This parameter cannot be used with the &#x60;groupname&#x60; parameter.
func (r ApiRemoveGroupRequest) GroupId(groupId string) ApiRemoveGroupRequest {
	r.groupId = &groupId
	return r
}

// As a group&#39;s name can change, use of &#x60;swapGroupId&#x60; is recommended to identify a group.   The group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs are inaccessible after the deletion. This parameter cannot be used with the &#x60;swapGroupId&#x60; parameter.
func (r ApiRemoveGroupRequest) SwapGroup(swapGroup string) ApiRemoveGroupRequest {
	r.swapGroup = &swapGroup
	return r
}

// The ID of the group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs are inaccessible after the deletion. This parameter cannot be used with the &#x60;swapGroup&#x60; parameter.
func (r ApiRemoveGroupRequest) SwapGroupId(swapGroupId string) ApiRemoveGroupRequest {
	r.swapGroupId = &swapGroupId
	return r
}

func (r ApiRemoveGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGroupExecute(r)
}

/*
RemoveGroup Remove group

Deletes a group.

**[Permissions](#permissions) required:** Site administration (that is, member of the *site-admin* strategic [group](https://confluence.atlassian.com/x/24xjL)).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveGroupRequest
*/
func (a *GroupsAPIService) RemoveGroup(ctx context.Context) ApiRemoveGroupRequest {
	return ApiRemoveGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *GroupsAPIService) RemoveGroupExecute(r ApiRemoveGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.RemoveGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupname", r.groupname, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.swapGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swapGroup", r.swapGroup, "form", "")
	}
	if r.swapGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swapGroupId", r.swapGroupId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveUserFromGroupRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	accountId *string
	groupname *string
	groupId *string
	username *string
}

// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
func (r ApiRemoveUserFromGroupRequest) AccountId(accountId string) ApiRemoveUserFromGroupRequest {
	r.accountId = &accountId
	return r
}

// As a group&#39;s name can change, use of &#x60;groupId&#x60; is recommended to identify a group.   The name of the group. This parameter cannot be used with the &#x60;groupId&#x60; parameter.
func (r ApiRemoveUserFromGroupRequest) Groupname(groupname string) ApiRemoveUserFromGroupRequest {
	r.groupname = &groupname
	return r
}

// The ID of the group. This parameter cannot be used with the &#x60;groupName&#x60; parameter.
func (r ApiRemoveUserFromGroupRequest) GroupId(groupId string) ApiRemoveUserFromGroupRequest {
	r.groupId = &groupId
	return r
}

// This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
func (r ApiRemoveUserFromGroupRequest) Username(username string) ApiRemoveUserFromGroupRequest {
	r.username = &username
	return r
}

func (r ApiRemoveUserFromGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveUserFromGroupExecute(r)
}

/*
RemoveUserFromGroup Remove user from group

Removes a user from a group.

**[Permissions](#permissions) required:** Site administration (that is, member of the *site-admin* [group](https://confluence.atlassian.com/x/24xjL)).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveUserFromGroupRequest
*/
func (a *GroupsAPIService) RemoveUserFromGroup(ctx context.Context) ApiRemoveUserFromGroupRequest {
	return ApiRemoveUserFromGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *GroupsAPIService) RemoveUserFromGroupExecute(r ApiRemoveUserFromGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.RemoveUserFromGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/group/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if strlen(*r.accountId) > 128 {
		return nil, reportError("accountId must have less than 128 elements")
	}

	if r.groupname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupname", r.groupname, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
