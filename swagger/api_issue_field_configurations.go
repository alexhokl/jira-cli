/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IssueFieldConfigurationsAPIService IssueFieldConfigurationsAPI service
type IssueFieldConfigurationsAPIService service

type ApiAssignFieldConfigurationSchemeToProjectRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	fieldConfigurationSchemeProjectAssociation *FieldConfigurationSchemeProjectAssociation
}

func (r ApiAssignFieldConfigurationSchemeToProjectRequest) FieldConfigurationSchemeProjectAssociation(fieldConfigurationSchemeProjectAssociation FieldConfigurationSchemeProjectAssociation) ApiAssignFieldConfigurationSchemeToProjectRequest {
	r.fieldConfigurationSchemeProjectAssociation = &fieldConfigurationSchemeProjectAssociation
	return r
}

func (r ApiAssignFieldConfigurationSchemeToProjectRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AssignFieldConfigurationSchemeToProjectExecute(r)
}

/*
AssignFieldConfigurationSchemeToProject Assign field configuration scheme to project

Assigns a field configuration scheme to a project. If the field configuration scheme ID is `null`, the operation assigns the default field configuration scheme.

Field configuration schemes can only be assigned to classic projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssignFieldConfigurationSchemeToProjectRequest
*/
func (a *IssueFieldConfigurationsAPIService) AssignFieldConfigurationSchemeToProject(ctx context.Context) ApiAssignFieldConfigurationSchemeToProjectRequest {
	return ApiAssignFieldConfigurationSchemeToProjectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueFieldConfigurationsAPIService) AssignFieldConfigurationSchemeToProjectExecute(r ApiAssignFieldConfigurationSchemeToProjectRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.AssignFieldConfigurationSchemeToProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fieldConfigurationSchemeProjectAssociation == nil {
		return localVarReturnValue, nil, reportError("fieldConfigurationSchemeProjectAssociation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fieldConfigurationSchemeProjectAssociation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFieldConfigurationRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	fieldConfigurationDetails *FieldConfigurationDetails
}

func (r ApiCreateFieldConfigurationRequest) FieldConfigurationDetails(fieldConfigurationDetails FieldConfigurationDetails) ApiCreateFieldConfigurationRequest {
	r.fieldConfigurationDetails = &fieldConfigurationDetails
	return r
}

func (r ApiCreateFieldConfigurationRequest) Execute() (*FieldConfiguration, *http.Response, error) {
	return r.ApiService.CreateFieldConfigurationExecute(r)
}

/*
CreateFieldConfiguration Create field configuration

Deprecated, use [Field schemes](#api-group-field-schemes) which supports field association schemes.

Creates a field configuration. The field configuration is created with the same field properties as the default configuration, with all the fields being optional.

This operation can only create configurations for use in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFieldConfigurationRequest

Deprecated
*/
func (a *IssueFieldConfigurationsAPIService) CreateFieldConfiguration(ctx context.Context) ApiCreateFieldConfigurationRequest {
	return ApiCreateFieldConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldConfiguration
// Deprecated
func (a *IssueFieldConfigurationsAPIService) CreateFieldConfigurationExecute(r ApiCreateFieldConfigurationRequest) (*FieldConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.CreateFieldConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfiguration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fieldConfigurationDetails == nil {
		return localVarReturnValue, nil, reportError("fieldConfigurationDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fieldConfigurationDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFieldConfigurationSchemeRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	updateFieldConfigurationSchemeDetails *UpdateFieldConfigurationSchemeDetails
}

// The details of the field configuration scheme.
func (r ApiCreateFieldConfigurationSchemeRequest) UpdateFieldConfigurationSchemeDetails(updateFieldConfigurationSchemeDetails UpdateFieldConfigurationSchemeDetails) ApiCreateFieldConfigurationSchemeRequest {
	r.updateFieldConfigurationSchemeDetails = &updateFieldConfigurationSchemeDetails
	return r
}

func (r ApiCreateFieldConfigurationSchemeRequest) Execute() (*FieldConfigurationScheme, *http.Response, error) {
	return r.ApiService.CreateFieldConfigurationSchemeExecute(r)
}

/*
CreateFieldConfigurationScheme Create field configuration scheme

Creates a field configuration scheme.

This operation can only create field configuration schemes used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFieldConfigurationSchemeRequest
*/
func (a *IssueFieldConfigurationsAPIService) CreateFieldConfigurationScheme(ctx context.Context) ApiCreateFieldConfigurationSchemeRequest {
	return ApiCreateFieldConfigurationSchemeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldConfigurationScheme
func (a *IssueFieldConfigurationsAPIService) CreateFieldConfigurationSchemeExecute(r ApiCreateFieldConfigurationSchemeRequest) (*FieldConfigurationScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldConfigurationScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.CreateFieldConfigurationScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldConfigurationSchemeDetails == nil {
		return localVarReturnValue, nil, reportError("updateFieldConfigurationSchemeDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldConfigurationSchemeDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFieldConfigurationRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
}

func (r ApiDeleteFieldConfigurationRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteFieldConfigurationExecute(r)
}

/*
DeleteFieldConfiguration Delete field configuration

Deprecated, use [Field schemes](#api-group-field-schemes) which supports field association schemes.

Deletes a field configuration.

This operation can only delete configurations used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration.
 @return ApiDeleteFieldConfigurationRequest

Deprecated
*/
func (a *IssueFieldConfigurationsAPIService) DeleteFieldConfiguration(ctx context.Context, id int64) ApiDeleteFieldConfigurationRequest {
	return ApiDeleteFieldConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
// Deprecated
func (a *IssueFieldConfigurationsAPIService) DeleteFieldConfigurationExecute(r ApiDeleteFieldConfigurationRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.DeleteFieldConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfiguration/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFieldConfigurationSchemeRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
}

func (r ApiDeleteFieldConfigurationSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteFieldConfigurationSchemeExecute(r)
}

/*
DeleteFieldConfigurationScheme Delete field configuration scheme

Deletes a field configuration scheme.

This operation can only delete field configuration schemes used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration scheme.
 @return ApiDeleteFieldConfigurationSchemeRequest
*/
func (a *IssueFieldConfigurationsAPIService) DeleteFieldConfigurationScheme(ctx context.Context, id int64) ApiDeleteFieldConfigurationSchemeRequest {
	return ApiDeleteFieldConfigurationSchemeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueFieldConfigurationsAPIService) DeleteFieldConfigurationSchemeExecute(r ApiDeleteFieldConfigurationSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.DeleteFieldConfigurationScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllFieldConfigurationSchemesRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	startAt *int64
	maxResults *int32
	id *[]int64
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetAllFieldConfigurationSchemesRequest) StartAt(startAt int64) ApiGetAllFieldConfigurationSchemesRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetAllFieldConfigurationSchemesRequest) MaxResults(maxResults int32) ApiGetAllFieldConfigurationSchemesRequest {
	r.maxResults = &maxResults
	return r
}

// The list of field configuration scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, &#x60;id&#x3D;10000&amp;id&#x3D;10001&#x60;.
func (r ApiGetAllFieldConfigurationSchemesRequest) Id(id []int64) ApiGetAllFieldConfigurationSchemesRequest {
	r.id = &id
	return r
}

func (r ApiGetAllFieldConfigurationSchemesRequest) Execute() (*PageBeanFieldConfigurationScheme, *http.Response, error) {
	return r.ApiService.GetAllFieldConfigurationSchemesExecute(r)
}

/*
GetAllFieldConfigurationSchemes Get all field configuration schemes

Returns a [paginated](#pagination) list of field configuration schemes.

Only field configuration schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllFieldConfigurationSchemesRequest
*/
func (a *IssueFieldConfigurationsAPIService) GetAllFieldConfigurationSchemes(ctx context.Context) ApiGetAllFieldConfigurationSchemesRequest {
	return ApiGetAllFieldConfigurationSchemesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanFieldConfigurationScheme
func (a *IssueFieldConfigurationsAPIService) GetAllFieldConfigurationSchemesExecute(r ApiGetAllFieldConfigurationSchemesRequest) (*PageBeanFieldConfigurationScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanFieldConfigurationScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.GetAllFieldConfigurationSchemes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllFieldConfigurationsRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	startAt *int64
	maxResults *int32
	id *[]int64
	isDefault *bool
	query *string
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetAllFieldConfigurationsRequest) StartAt(startAt int64) ApiGetAllFieldConfigurationsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetAllFieldConfigurationsRequest) MaxResults(maxResults int32) ApiGetAllFieldConfigurationsRequest {
	r.maxResults = &maxResults
	return r
}

// The list of field configuration IDs. To include multiple IDs, provide an ampersand-separated list. For example, &#x60;id&#x3D;10000&amp;id&#x3D;10001&#x60;.
func (r ApiGetAllFieldConfigurationsRequest) Id(id []int64) ApiGetAllFieldConfigurationsRequest {
	r.id = &id
	return r
}

// If *true* returns default field configurations only.
func (r ApiGetAllFieldConfigurationsRequest) IsDefault(isDefault bool) ApiGetAllFieldConfigurationsRequest {
	r.isDefault = &isDefault
	return r
}

// The query string used to match against field configuration names and descriptions.
func (r ApiGetAllFieldConfigurationsRequest) Query(query string) ApiGetAllFieldConfigurationsRequest {
	r.query = &query
	return r
}

func (r ApiGetAllFieldConfigurationsRequest) Execute() (*PageBeanFieldConfigurationDetails, *http.Response, error) {
	return r.ApiService.GetAllFieldConfigurationsExecute(r)
}

/*
GetAllFieldConfigurations Get all field configurations

Deprecated, use [Field schemes](#api-group-field-schemes) which supports field association schemes.

Returns a [paginated](#pagination) list of field configurations. The list can be for all field configurations or a subset determined by any combination of these criteria:

 *  a list of field configuration item IDs.
 *  whether the field configuration is a default.
 *  whether the field configuration name or description contains a query string.

Only field configurations used in company-managed (classic) projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllFieldConfigurationsRequest

Deprecated
*/
func (a *IssueFieldConfigurationsAPIService) GetAllFieldConfigurations(ctx context.Context) ApiGetAllFieldConfigurationsRequest {
	return ApiGetAllFieldConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanFieldConfigurationDetails
// Deprecated
func (a *IssueFieldConfigurationsAPIService) GetAllFieldConfigurationsExecute(r ApiGetAllFieldConfigurationsRequest) (*PageBeanFieldConfigurationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanFieldConfigurationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.GetAllFieldConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfiguration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.isDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDefault", r.isDefault, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDefault", defaultValue, "form", "")
		r.isDefault = &defaultValue
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", defaultValue, "form", "")
		r.query = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldConfigurationItemsRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
	startAt *int64
	maxResults *int32
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetFieldConfigurationItemsRequest) StartAt(startAt int64) ApiGetFieldConfigurationItemsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetFieldConfigurationItemsRequest) MaxResults(maxResults int32) ApiGetFieldConfigurationItemsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetFieldConfigurationItemsRequest) Execute() (*PageBeanFieldConfigurationItem, *http.Response, error) {
	return r.ApiService.GetFieldConfigurationItemsExecute(r)
}

/*
GetFieldConfigurationItems Get field configuration items

Deprecated, use [Field schemes](#api-group-field-schemes) which supports field association schemes.

Returns a [paginated](#pagination) list of all fields for a configuration.

Only the fields from configurations used in company-managed (classic) projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration.
 @return ApiGetFieldConfigurationItemsRequest

Deprecated
*/
func (a *IssueFieldConfigurationsAPIService) GetFieldConfigurationItems(ctx context.Context, id int64) ApiGetFieldConfigurationItemsRequest {
	return ApiGetFieldConfigurationItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PageBeanFieldConfigurationItem
// Deprecated
func (a *IssueFieldConfigurationsAPIService) GetFieldConfigurationItemsExecute(r ApiGetFieldConfigurationItemsRequest) (*PageBeanFieldConfigurationItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanFieldConfigurationItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.GetFieldConfigurationItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfiguration/{id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldConfigurationSchemeMappingsRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	startAt *int64
	maxResults *int32
	fieldConfigurationSchemeId *[]int64
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetFieldConfigurationSchemeMappingsRequest) StartAt(startAt int64) ApiGetFieldConfigurationSchemeMappingsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetFieldConfigurationSchemeMappingsRequest) MaxResults(maxResults int32) ApiGetFieldConfigurationSchemeMappingsRequest {
	r.maxResults = &maxResults
	return r
}

// The list of field configuration scheme IDs. To include multiple field configuration schemes separate IDs with ampersand: &#x60;fieldConfigurationSchemeId&#x3D;10000&amp;fieldConfigurationSchemeId&#x3D;10001&#x60;.
func (r ApiGetFieldConfigurationSchemeMappingsRequest) FieldConfigurationSchemeId(fieldConfigurationSchemeId []int64) ApiGetFieldConfigurationSchemeMappingsRequest {
	r.fieldConfigurationSchemeId = &fieldConfigurationSchemeId
	return r
}

func (r ApiGetFieldConfigurationSchemeMappingsRequest) Execute() (*PageBeanFieldConfigurationIssueTypeItem, *http.Response, error) {
	return r.ApiService.GetFieldConfigurationSchemeMappingsExecute(r)
}

/*
GetFieldConfigurationSchemeMappings Get field configuration issue type items

Returns a [paginated](#pagination) list of field configuration issue type items.

Only items used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFieldConfigurationSchemeMappingsRequest
*/
func (a *IssueFieldConfigurationsAPIService) GetFieldConfigurationSchemeMappings(ctx context.Context) ApiGetFieldConfigurationSchemeMappingsRequest {
	return ApiGetFieldConfigurationSchemeMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanFieldConfigurationIssueTypeItem
func (a *IssueFieldConfigurationsAPIService) GetFieldConfigurationSchemeMappingsExecute(r ApiGetFieldConfigurationSchemeMappingsRequest) (*PageBeanFieldConfigurationIssueTypeItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanFieldConfigurationIssueTypeItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.GetFieldConfigurationSchemeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.fieldConfigurationSchemeId != nil {
		t := *r.fieldConfigurationSchemeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fieldConfigurationSchemeId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fieldConfigurationSchemeId", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldConfigurationSchemeProjectMappingRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	projectId *[]int64
	startAt *int64
	maxResults *int32
}

// The list of project IDs. To include multiple projects, separate IDs with ampersand: &#x60;projectId&#x3D;10000&amp;projectId&#x3D;10001&#x60;.
func (r ApiGetFieldConfigurationSchemeProjectMappingRequest) ProjectId(projectId []int64) ApiGetFieldConfigurationSchemeProjectMappingRequest {
	r.projectId = &projectId
	return r
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetFieldConfigurationSchemeProjectMappingRequest) StartAt(startAt int64) ApiGetFieldConfigurationSchemeProjectMappingRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetFieldConfigurationSchemeProjectMappingRequest) MaxResults(maxResults int32) ApiGetFieldConfigurationSchemeProjectMappingRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetFieldConfigurationSchemeProjectMappingRequest) Execute() (*PageBeanFieldConfigurationSchemeProjects, *http.Response, error) {
	return r.ApiService.GetFieldConfigurationSchemeProjectMappingExecute(r)
}

/*
GetFieldConfigurationSchemeProjectMapping Get field configuration schemes for projects

Returns a [paginated](#pagination) list of field configuration schemes and, for each scheme, a list of the projects that use it.

The list is sorted by field configuration scheme ID. The first item contains the list of project IDs assigned to the default field configuration scheme.

Only field configuration schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFieldConfigurationSchemeProjectMappingRequest
*/
func (a *IssueFieldConfigurationsAPIService) GetFieldConfigurationSchemeProjectMapping(ctx context.Context) ApiGetFieldConfigurationSchemeProjectMappingRequest {
	return ApiGetFieldConfigurationSchemeProjectMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanFieldConfigurationSchemeProjects
func (a *IssueFieldConfigurationsAPIService) GetFieldConfigurationSchemeProjectMappingExecute(r ApiGetFieldConfigurationSchemeProjectMappingRequest) (*PageBeanFieldConfigurationSchemeProjects, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanFieldConfigurationSchemeProjects
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.GetFieldConfigurationSchemeProjectMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	{
		t := *r.projectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
	issueTypeIdsToRemove *IssueTypeIdsToRemove
}

// The issue type IDs to remove.
func (r ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest) IssueTypeIdsToRemove(issueTypeIdsToRemove IssueTypeIdsToRemove) ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest {
	r.issueTypeIdsToRemove = &issueTypeIdsToRemove
	return r
}

func (r ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.RemoveIssueTypesFromGlobalFieldConfigurationSchemeExecute(r)
}

/*
RemoveIssueTypesFromGlobalFieldConfigurationScheme Remove issue types from field configuration scheme

Removes issue types from the field configuration scheme.

This operation can only modify field configuration schemes used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration scheme.
 @return ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest
*/
func (a *IssueFieldConfigurationsAPIService) RemoveIssueTypesFromGlobalFieldConfigurationScheme(ctx context.Context, id int64) ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest {
	return ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueFieldConfigurationsAPIService) RemoveIssueTypesFromGlobalFieldConfigurationSchemeExecute(r ApiRemoveIssueTypesFromGlobalFieldConfigurationSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.RemoveIssueTypesFromGlobalFieldConfigurationScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/{id}/mapping/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeIdsToRemove == nil {
		return localVarReturnValue, nil, reportError("issueTypeIdsToRemove is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeIdsToRemove
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetFieldConfigurationSchemeMappingRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
	associateFieldConfigurationsWithIssueTypesRequest *AssociateFieldConfigurationsWithIssueTypesRequest
}

func (r ApiSetFieldConfigurationSchemeMappingRequest) AssociateFieldConfigurationsWithIssueTypesRequest(associateFieldConfigurationsWithIssueTypesRequest AssociateFieldConfigurationsWithIssueTypesRequest) ApiSetFieldConfigurationSchemeMappingRequest {
	r.associateFieldConfigurationsWithIssueTypesRequest = &associateFieldConfigurationsWithIssueTypesRequest
	return r
}

func (r ApiSetFieldConfigurationSchemeMappingRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SetFieldConfigurationSchemeMappingExecute(r)
}

/*
SetFieldConfigurationSchemeMapping Assign issue types to field configurations

Assigns issue types to field configurations on field configuration scheme.

This operation can only modify field configuration schemes used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration scheme.
 @return ApiSetFieldConfigurationSchemeMappingRequest
*/
func (a *IssueFieldConfigurationsAPIService) SetFieldConfigurationSchemeMapping(ctx context.Context, id int64) ApiSetFieldConfigurationSchemeMappingRequest {
	return ApiSetFieldConfigurationSchemeMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueFieldConfigurationsAPIService) SetFieldConfigurationSchemeMappingExecute(r ApiSetFieldConfigurationSchemeMappingRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.SetFieldConfigurationSchemeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/{id}/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.associateFieldConfigurationsWithIssueTypesRequest == nil {
		return localVarReturnValue, nil, reportError("associateFieldConfigurationsWithIssueTypesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.associateFieldConfigurationsWithIssueTypesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFieldConfigurationRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
	fieldConfigurationDetails *FieldConfigurationDetails
}

func (r ApiUpdateFieldConfigurationRequest) FieldConfigurationDetails(fieldConfigurationDetails FieldConfigurationDetails) ApiUpdateFieldConfigurationRequest {
	r.fieldConfigurationDetails = &fieldConfigurationDetails
	return r
}

func (r ApiUpdateFieldConfigurationRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateFieldConfigurationExecute(r)
}

/*
UpdateFieldConfiguration Update field configuration

Deprecated, use [Field schemes](#api-group-field-schemes) which supports field association schemes.

Updates a field configuration. The name and the description provided in the request override the existing values.

This operation can only update configurations used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration.
 @return ApiUpdateFieldConfigurationRequest

Deprecated
*/
func (a *IssueFieldConfigurationsAPIService) UpdateFieldConfiguration(ctx context.Context, id int64) ApiUpdateFieldConfigurationRequest {
	return ApiUpdateFieldConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
// Deprecated
func (a *IssueFieldConfigurationsAPIService) UpdateFieldConfigurationExecute(r ApiUpdateFieldConfigurationRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.UpdateFieldConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfiguration/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fieldConfigurationDetails == nil {
		return localVarReturnValue, nil, reportError("fieldConfigurationDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fieldConfigurationDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFieldConfigurationItemsRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
	fieldConfigurationItemsDetails *FieldConfigurationItemsDetails
}

func (r ApiUpdateFieldConfigurationItemsRequest) FieldConfigurationItemsDetails(fieldConfigurationItemsDetails FieldConfigurationItemsDetails) ApiUpdateFieldConfigurationItemsRequest {
	r.fieldConfigurationItemsDetails = &fieldConfigurationItemsDetails
	return r
}

func (r ApiUpdateFieldConfigurationItemsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateFieldConfigurationItemsExecute(r)
}

/*
UpdateFieldConfigurationItems Update field configuration items

Deprecated, use [Field schemes](#api-group-field-schemes) which supports field association schemes.

Updates fields in a field configuration. The properties of the field configuration fields provided override the existing values.

This operation can only update field configurations used in company-managed (classic) projects.

The operation can set the renderer for text fields to the default text renderer (`text-renderer`) or wiki style renderer (`wiki-renderer`). However, the renderer cannot be updated for fields using the autocomplete renderer (`autocomplete-renderer`).

Hiding a field deletes it from the field configuration - deleting the required, description and renderer type values as well. As a result, hiding and unhiding will not restore the other values but use their default values.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration.
 @return ApiUpdateFieldConfigurationItemsRequest

Deprecated
*/
func (a *IssueFieldConfigurationsAPIService) UpdateFieldConfigurationItems(ctx context.Context, id int64) ApiUpdateFieldConfigurationItemsRequest {
	return ApiUpdateFieldConfigurationItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
// Deprecated
func (a *IssueFieldConfigurationsAPIService) UpdateFieldConfigurationItemsExecute(r ApiUpdateFieldConfigurationItemsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.UpdateFieldConfigurationItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfiguration/{id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fieldConfigurationItemsDetails == nil {
		return localVarReturnValue, nil, reportError("fieldConfigurationItemsDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fieldConfigurationItemsDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFieldConfigurationSchemeRequest struct {
	ctx context.Context
	ApiService *IssueFieldConfigurationsAPIService
	id int64
	updateFieldConfigurationSchemeDetails *UpdateFieldConfigurationSchemeDetails
}

// The details of the field configuration scheme.
func (r ApiUpdateFieldConfigurationSchemeRequest) UpdateFieldConfigurationSchemeDetails(updateFieldConfigurationSchemeDetails UpdateFieldConfigurationSchemeDetails) ApiUpdateFieldConfigurationSchemeRequest {
	r.updateFieldConfigurationSchemeDetails = &updateFieldConfigurationSchemeDetails
	return r
}

func (r ApiUpdateFieldConfigurationSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateFieldConfigurationSchemeExecute(r)
}

/*
UpdateFieldConfigurationScheme Update field configuration scheme

Updates a field configuration scheme.

This operation can only update field configuration schemes used in company-managed (classic) projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field configuration scheme.
 @return ApiUpdateFieldConfigurationSchemeRequest
*/
func (a *IssueFieldConfigurationsAPIService) UpdateFieldConfigurationScheme(ctx context.Context, id int64) ApiUpdateFieldConfigurationSchemeRequest {
	return ApiUpdateFieldConfigurationSchemeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueFieldConfigurationsAPIService) UpdateFieldConfigurationSchemeExecute(r ApiUpdateFieldConfigurationSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueFieldConfigurationsAPIService.UpdateFieldConfigurationScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/fieldconfigurationscheme/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldConfigurationSchemeDetails == nil {
		return localVarReturnValue, nil, reportError("updateFieldConfigurationSchemeDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldConfigurationSchemeDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
