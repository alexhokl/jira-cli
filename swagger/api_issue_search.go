/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// IssueSearchAPIService IssueSearchAPI service
type IssueSearchAPIService service

type ApiCountIssuesRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	jQLCountRequestBean *JQLCountRequestBean
}

// A JSON object containing the search request.
func (r ApiCountIssuesRequest) JQLCountRequestBean(jQLCountRequestBean JQLCountRequestBean) ApiCountIssuesRequest {
	r.jQLCountRequestBean = &jQLCountRequestBean
	return r
}

func (r ApiCountIssuesRequest) Execute() (*JQLCountResultsBean, *http.Response, error) {
	return r.ApiService.CountIssuesExecute(r)
}

/*
CountIssues Count issues using JQL

Provide an estimated count of the issues that match the [JQL](https://confluence.atlassian.com/x/egORLQ). Recent updates might not be immediately visible in the returned output. This endpoint requires JQL to be bounded.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** Issues are included in the response where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountIssuesRequest
*/
func (a *IssueSearchAPIService) CountIssues(ctx context.Context) ApiCountIssuesRequest {
	return ApiCountIssuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JQLCountResultsBean
func (a *IssueSearchAPIService) CountIssuesExecute(r ApiCountIssuesRequest) (*JQLCountResultsBean, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JQLCountResultsBean
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.CountIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/search/approximate-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jQLCountRequestBean == nil {
		return localVarReturnValue, nil, reportError("jQLCountRequestBean is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jQLCountRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuePickerResourceRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	query *string
	currentJQL *string
	currentIssueKey *string
	currentProjectId *string
	showSubTasks *bool
	showSubTaskParent *bool
}

// A string to match against text fields in the issue such as title, description, or comments.
func (r ApiGetIssuePickerResourceRequest) Query(query string) ApiGetIssuePickerResourceRequest {
	r.query = &query
	return r
}

// A JQL query defining a list of issues to search for the query term. Note that &#x60;username&#x60; and &#x60;userkey&#x60; cannot be used as search terms for this parameter, due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetIssuePickerResourceRequest) CurrentJQL(currentJQL string) ApiGetIssuePickerResourceRequest {
	r.currentJQL = &currentJQL
	return r
}

// The key of an issue to exclude from search results. For example, the issue the user is viewing when they perform this query.
func (r ApiGetIssuePickerResourceRequest) CurrentIssueKey(currentIssueKey string) ApiGetIssuePickerResourceRequest {
	r.currentIssueKey = &currentIssueKey
	return r
}

// The ID of a project that suggested issues must belong to.
func (r ApiGetIssuePickerResourceRequest) CurrentProjectId(currentProjectId string) ApiGetIssuePickerResourceRequest {
	r.currentProjectId = &currentProjectId
	return r
}

// Indicate whether to include subtasks in the suggestions list.
func (r ApiGetIssuePickerResourceRequest) ShowSubTasks(showSubTasks bool) ApiGetIssuePickerResourceRequest {
	r.showSubTasks = &showSubTasks
	return r
}

// When &#x60;currentIssueKey&#x60; is a subtask, whether to include the parent issue in the suggestions if it matches the query.
func (r ApiGetIssuePickerResourceRequest) ShowSubTaskParent(showSubTaskParent bool) ApiGetIssuePickerResourceRequest {
	r.showSubTaskParent = &showSubTaskParent
	return r
}

func (r ApiGetIssuePickerResourceRequest) Execute() (*IssuePickerSuggestions, *http.Response, error) {
	return r.ApiService.GetIssuePickerResourceExecute(r)
}

/*
GetIssuePickerResource Get issue picker suggestions

Returns lists of issues matching a query string. Use this resource to provide auto-completion suggestions when the user is looking for an issue using a word or string.

This operation returns two lists:

 *  `History Search` which includes issues from the user's history of created, edited, or viewed issues that contain the string in the `query` parameter.
 *  `Current Search` which includes issues that match the JQL expression in `currentJQL` and contain the string in the `query` parameter.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** None.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuePickerResourceRequest
*/
func (a *IssueSearchAPIService) GetIssuePickerResource(ctx context.Context) ApiGetIssuePickerResourceRequest {
	return ApiGetIssuePickerResourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IssuePickerSuggestions
func (a *IssueSearchAPIService) GetIssuePickerResourceExecute(r ApiGetIssuePickerResourceRequest) (*IssuePickerSuggestions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IssuePickerSuggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.GetIssuePickerResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/picker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.currentJQL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentJQL", r.currentJQL, "form", "")
	}
	if r.currentIssueKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentIssueKey", r.currentIssueKey, "form", "")
	}
	if r.currentProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentProjectId", r.currentProjectId, "form", "")
	}
	if r.showSubTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showSubTasks", r.showSubTasks, "form", "")
	}
	if r.showSubTaskParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showSubTaskParent", r.showSubTaskParent, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMatchIssuesRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	issuesAndJQLQueries *IssuesAndJQLQueries
}

func (r ApiMatchIssuesRequest) IssuesAndJQLQueries(issuesAndJQLQueries IssuesAndJQLQueries) ApiMatchIssuesRequest {
	r.issuesAndJQLQueries = &issuesAndJQLQueries
	return r
}

func (r ApiMatchIssuesRequest) Execute() (*IssueMatches, *http.Response, error) {
	return r.ApiService.MatchIssuesExecute(r)
}

/*
MatchIssues Check issues against JQL

Checks whether one or more issues would be returned by one or more JQL queries.

**[Permissions](#permissions) required:** None, however, issues are only matched against JQL queries where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMatchIssuesRequest
*/
func (a *IssueSearchAPIService) MatchIssues(ctx context.Context) ApiMatchIssuesRequest {
	return ApiMatchIssuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IssueMatches
func (a *IssueSearchAPIService) MatchIssuesExecute(r ApiMatchIssuesRequest) (*IssueMatches, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IssueMatches
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.MatchIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/jql/match"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issuesAndJQLQueries == nil {
		return localVarReturnValue, nil, reportError("issuesAndJQLQueries is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issuesAndJQLQueries
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAndReconsileIssuesUsingJqlRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	jql *string
	nextPageToken *string
	maxResults *int32
	fields *[]string
	expand *string
	properties *[]string
	fieldsByKeys *bool
	failFast *bool
	reconcileIssues *[]int64
}

// A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. For performance reasons, this parameter requires a bounded query. A bounded query is a query with a search restriction.   *  Example of an unbounded query: &#x60;order by key desc&#x60;.  *  Example of a bounded query: &#x60;assignee &#x3D; currentUser() order by key&#x60;.  Additionally, &#x60;orderBy&#x60; clause can contain a maximum of 7 fields.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) Jql(jql string) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.jql = &jql
	return r
}

// The token for a page to fetch that is not the first page. The first page has a &#x60;nextPageToken&#x60; of &#x60;null&#x60;. Use the &#x60;nextPageToken&#x60; to fetch the next page of issues.  Note: The &#x60;nextPageToken&#x60; field is **not included** in the response for the last page, indicating there is no next page.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) NextPageToken(nextPageToken string) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.nextPageToken = &nextPageToken
	return r
}

// The maximum number of items to return per page. To manage page size, API may return fewer items per page where a large number of fields or properties are requested. The greatest number of items returned per page is achieved when requesting &#x60;id&#x60; or &#x60;key&#x60; only. It returns max 5000 issues.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) MaxResults(maxResults int32) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.maxResults = &maxResults
	return r
}

// A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  &#x60;id&#x60; Returns only issue IDs.  *  Any issue field, prefixed with a minus to exclude.  The default is &#x60;id&#x60;.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields only.  *  &#x60;-description&#x60; Returns all navigable (default) fields except description.  *  &#x60;*all,-comment&#x60; Returns all fields except comments.  Multiple &#x60;fields&#x60; parameters can be included in a request.  Note: By default, this resource returns IDs only. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) Fields(fields []string) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.fields = &fields
	return r
}

// Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where &#x60;expand&#x60; is specified, &#x60;expand&#x60; is defined as a comma-delimited string of values. The expand options are:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;operations&#x60; Returns all possible operations for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Instead of &#x60;fields&#x60;, returns &#x60;versionedRepresentations&#x60; a JSON array containing each version of a field&#39;s value, with the highest numbered item representing the most recent version.  Examples: &#x60;\&quot;names,changelog\&quot;&#x60; Returns the display name of each field as well as a list of recent updates to an issue.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) Expand(expand string) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.expand = &expand
	return r
}

// A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) Properties(properties []string) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.properties = &properties
	return r
}

// Reference fields by their key (rather than ID). The default is &#x60;false&#x60;.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) FieldsByKeys(fieldsByKeys bool) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.fieldsByKeys = &fieldsByKeys
	return r
}

// Fail this request early if we can&#39;t retrieve all field data.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) FailFast(failFast bool) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.failFast = &failFast
	return r
}

// Strong consistency issue ids to be reconciled with search results. Accepts max 50 ids. This list of ids should be consistent with each paginated request across different pages.
func (r ApiSearchAndReconsileIssuesUsingJqlRequest) ReconcileIssues(reconcileIssues []int64) ApiSearchAndReconsileIssuesUsingJqlRequest {
	r.reconcileIssues = &reconcileIssues
	return r
}

func (r ApiSearchAndReconsileIssuesUsingJqlRequest) Execute() (*SearchAndReconcileResults, *http.Response, error) {
	return r.ApiService.SearchAndReconsileIssuesUsingJqlExecute(r)
}

/*
SearchAndReconsileIssuesUsingJql Search for issues using JQL enhanced search (GET)

Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ). Recent updates might not be immediately visible in the returned search results. If you need [read-after-write](https://developer.atlassian.com/cloud/jira/platform/search-and-reconcile/) consistency, you can utilize the `reconcileIssues` parameter to ensure stronger consistency assurances. This operation can be accessed anonymously.

If the JQL query expression is too large to be encoded as a query parameter, use the [POST](#api-rest-api-3-search-post) version of this resource.

**[Permissions](#permissions) required:** Issues are included in the response where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchAndReconsileIssuesUsingJqlRequest
*/
func (a *IssueSearchAPIService) SearchAndReconsileIssuesUsingJql(ctx context.Context) ApiSearchAndReconsileIssuesUsingJqlRequest {
	return ApiSearchAndReconsileIssuesUsingJqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchAndReconcileResults
func (a *IssueSearchAPIService) SearchAndReconsileIssuesUsingJqlExecute(r ApiSearchAndReconsileIssuesUsingJqlRequest) (*SearchAndReconcileResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchAndReconcileResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.SearchAndReconsileIssuesUsingJql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/search/jql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.nextPageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageToken", r.nextPageToken, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.fieldsByKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldsByKeys", r.fieldsByKeys, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldsByKeys", defaultValue, "form", "")
		r.fieldsByKeys = &defaultValue
	}
	if r.failFast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failFast", r.failFast, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "failFast", defaultValue, "form", "")
		r.failFast = &defaultValue
	}
	if r.reconcileIssues != nil {
		t := *r.reconcileIssues
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reconcileIssues", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reconcileIssues", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAndReconsileIssuesUsingJqlPostRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	searchAndReconcileRequestBean *SearchAndReconcileRequestBean
}

func (r ApiSearchAndReconsileIssuesUsingJqlPostRequest) SearchAndReconcileRequestBean(searchAndReconcileRequestBean SearchAndReconcileRequestBean) ApiSearchAndReconsileIssuesUsingJqlPostRequest {
	r.searchAndReconcileRequestBean = &searchAndReconcileRequestBean
	return r
}

func (r ApiSearchAndReconsileIssuesUsingJqlPostRequest) Execute() (*SearchAndReconcileResults, *http.Response, error) {
	return r.ApiService.SearchAndReconsileIssuesUsingJqlPostExecute(r)
}

/*
SearchAndReconsileIssuesUsingJqlPost Search for issues using JQL enhanced search (POST)

Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ). Recent updates might not be immediately visible in the returned search results. If you need [read-after-write](https://developer.atlassian.com/cloud/jira/platform/search-and-reconcile/) consistency, you can utilize the `reconcileIssues` parameter to ensure stronger consistency assurances. This operation can be accessed anonymously.

**[Permissions](#permissions) required:** Issues are included in the response where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchAndReconsileIssuesUsingJqlPostRequest
*/
func (a *IssueSearchAPIService) SearchAndReconsileIssuesUsingJqlPost(ctx context.Context) ApiSearchAndReconsileIssuesUsingJqlPostRequest {
	return ApiSearchAndReconsileIssuesUsingJqlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchAndReconcileResults
func (a *IssueSearchAPIService) SearchAndReconsileIssuesUsingJqlPostExecute(r ApiSearchAndReconsileIssuesUsingJqlPostRequest) (*SearchAndReconcileResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchAndReconcileResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.SearchAndReconsileIssuesUsingJqlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/search/jql"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchAndReconcileRequestBean == nil {
		return localVarReturnValue, nil, reportError("searchAndReconcileRequestBean is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchAndReconcileRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForIssuesUsingJqlRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	jql *string
	startAt *int32
	maxResults *int32
	validateQuery *string
	fields *[]string
	expand *string
	properties *[]string
	fieldsByKeys *bool
	failFast *bool
}

// The [JQL](https://confluence.atlassian.com/x/egORLQ) that defines the search. Note:   *  If no JQL expression is provided, all issues are returned.  *  &#x60;username&#x60; and &#x60;userkey&#x60; cannot be used as search terms due to privacy reasons. Use &#x60;accountId&#x60; instead.  *  If a user has hidden their email address in their user profile, partial matches of the email address will not find the user. An exact match is required.
func (r ApiSearchForIssuesUsingJqlRequest) Jql(jql string) ApiSearchForIssuesUsingJqlRequest {
	r.jql = &jql
	return r
}

// The index of the first item to return in a page of results (page offset).
func (r ApiSearchForIssuesUsingJqlRequest) StartAt(startAt int32) ApiSearchForIssuesUsingJqlRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page. To manage page size, Jira may return fewer items per page where a large number of fields or properties are requested. The greatest number of items returned per page is achieved when requesting &#x60;id&#x60; or &#x60;key&#x60; only.
func (r ApiSearchForIssuesUsingJqlRequest) MaxResults(maxResults int32) ApiSearchForIssuesUsingJqlRequest {
	r.maxResults = &maxResults
	return r
}

// Determines how to validate the JQL query and treat the validation results. Supported values are:   *  &#x60;strict&#x60; Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).  *  &#x60;warn&#x60; Returns all errors as warnings.  *  &#x60;none&#x60; No validation is performed.  *  &#x60;true&#x60; *Deprecated* A legacy synonym for &#x60;strict&#x60;.  *  &#x60;false&#x60; *Deprecated* A legacy synonym for &#x60;warn&#x60;.  Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the &#x60;validateQuery&#x60; value.
func (r ApiSearchForIssuesUsingJqlRequest) ValidateQuery(validateQuery string) ApiSearchForIssuesUsingJqlRequest {
	r.validateQuery = &validateQuery
	return r
}

// A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all navigable (default) fields except description.  *  &#x60;*all,-comment&#x60; Returns all fields except comments.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp;fields&#x3D;field3&#x60;.  Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.
func (r ApiSearchForIssuesUsingJqlRequest) Fields(fields []string) ApiSearchForIssuesUsingJqlRequest {
	r.fields = &fields
	return r
}

// Use [expand](#expansion) to include additional information about issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;operations&#x60; Returns all possible operations for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Instead of &#x60;fields&#x60;, returns &#x60;versionedRepresentations&#x60; a JSON array containing each version of a field&#39;s value, with the highest numbered item representing the most recent version.
func (r ApiSearchForIssuesUsingJqlRequest) Expand(expand string) ApiSearchForIssuesUsingJqlRequest {
	r.expand = &expand
	return r
}

// A list of issue property keys for issue properties to include in the results. This parameter accepts a comma-separated list. Multiple properties can also be provided using an ampersand separated list. For example, &#x60;properties&#x3D;prop1,prop2&amp;properties&#x3D;prop3&#x60;. A maximum of 5 issue property keys can be specified.
func (r ApiSearchForIssuesUsingJqlRequest) Properties(properties []string) ApiSearchForIssuesUsingJqlRequest {
	r.properties = &properties
	return r
}

// Reference fields by their key (rather than ID).
func (r ApiSearchForIssuesUsingJqlRequest) FieldsByKeys(fieldsByKeys bool) ApiSearchForIssuesUsingJqlRequest {
	r.fieldsByKeys = &fieldsByKeys
	return r
}

// Whether to fail the request quickly in case of an error while loading fields for an issue. For &#x60;failFast&#x3D;true&#x60;, if one field fails, the entire operation fails. For &#x60;failFast&#x3D;false&#x60;, the operation will continue even if a field fails. It will return a valid response, but without values for the failed field(s).
func (r ApiSearchForIssuesUsingJqlRequest) FailFast(failFast bool) ApiSearchForIssuesUsingJqlRequest {
	r.failFast = &failFast
	return r
}

func (r ApiSearchForIssuesUsingJqlRequest) Execute() (*SearchResults, *http.Response, error) {
	return r.ApiService.SearchForIssuesUsingJqlExecute(r)
}

/*
SearchForIssuesUsingJql Currently being removed. Search for issues using JQL (GET)

Endpoint is currently being removed. [More details](https://developer.atlassian.com/changelog/#CHANGE-2046)

Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).

If the JQL query expression is too large to be encoded as a query parameter, use the [POST](#api-rest-api-3-search-post) version of this resource.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** Issues are included in the response where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchForIssuesUsingJqlRequest

Deprecated
*/
func (a *IssueSearchAPIService) SearchForIssuesUsingJql(ctx context.Context) ApiSearchForIssuesUsingJqlRequest {
	return ApiSearchForIssuesUsingJqlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResults
// Deprecated
func (a *IssueSearchAPIService) SearchForIssuesUsingJqlExecute(r ApiSearchForIssuesUsingJqlRequest) (*SearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.SearchForIssuesUsingJql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	} else {
		var defaultValue string = "strict"
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", defaultValue, "form", "")
		r.validateQuery = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.fieldsByKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldsByKeys", r.fieldsByKeys, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldsByKeys", defaultValue, "form", "")
		r.fieldsByKeys = &defaultValue
	}
	if r.failFast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failFast", r.failFast, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "failFast", defaultValue, "form", "")
		r.failFast = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForIssuesUsingJqlPostRequest struct {
	ctx context.Context
	ApiService *IssueSearchAPIService
	searchRequestBean *SearchRequestBean
}

// A JSON object containing the search request.
func (r ApiSearchForIssuesUsingJqlPostRequest) SearchRequestBean(searchRequestBean SearchRequestBean) ApiSearchForIssuesUsingJqlPostRequest {
	r.searchRequestBean = &searchRequestBean
	return r
}

func (r ApiSearchForIssuesUsingJqlPostRequest) Execute() (*SearchResults, *http.Response, error) {
	return r.ApiService.SearchForIssuesUsingJqlPostExecute(r)
}

/*
SearchForIssuesUsingJqlPost Currently being removed. Search for issues using JQL (POST)

Endpoint is currently being removed. [More details](https://developer.atlassian.com/changelog/#CHANGE-2046)

Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).

There is a [GET](#api-rest-api-3-search-get) version of this resource that can be used for smaller JQL query expressions.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** Issues are included in the response where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchForIssuesUsingJqlPostRequest

Deprecated
*/
func (a *IssueSearchAPIService) SearchForIssuesUsingJqlPost(ctx context.Context) ApiSearchForIssuesUsingJqlPostRequest {
	return ApiSearchForIssuesUsingJqlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResults
// Deprecated
func (a *IssueSearchAPIService) SearchForIssuesUsingJqlPostExecute(r ApiSearchForIssuesUsingJqlPostRequest) (*SearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueSearchAPIService.SearchForIssuesUsingJqlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchRequestBean == nil {
		return localVarReturnValue, nil, reportError("searchRequestBean is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
