/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// IssueCustomFieldOptionsAPIService IssueCustomFieldOptionsAPI service
type IssueCustomFieldOptionsAPIService service

type ApiCreateCustomFieldOptionRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	fieldId string
	contextId int64
	bulkCustomFieldOptionCreateRequest *BulkCustomFieldOptionCreateRequest
}

func (r ApiCreateCustomFieldOptionRequest) BulkCustomFieldOptionCreateRequest(bulkCustomFieldOptionCreateRequest BulkCustomFieldOptionCreateRequest) ApiCreateCustomFieldOptionRequest {
	r.bulkCustomFieldOptionCreateRequest = &bulkCustomFieldOptionCreateRequest
	return r
}

func (r ApiCreateCustomFieldOptionRequest) Execute() (*CustomFieldCreatedContextOptionsList, *http.Response, error) {
	return r.ApiService.CreateCustomFieldOptionExecute(r)
}

/*
CreateCustomFieldOption Create custom field options (context)

Creates options and, where the custom select field is of the type Select List (cascading), cascading options for a custom select field. The options are added to a context of the field.

The maximum number of options that can be created per request is 1000 and each field can have a maximum of 10000 options.

This operation works for custom field options created in Jira or the operations from this resource. **To work with issue field select list options created for Connect apps use the [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-) operations.**

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The ID of the custom field.
 @param contextId The ID of the context.
 @return ApiCreateCustomFieldOptionRequest
*/
func (a *IssueCustomFieldOptionsAPIService) CreateCustomFieldOption(ctx context.Context, fieldId string, contextId int64) ApiCreateCustomFieldOptionRequest {
	return ApiCreateCustomFieldOptionRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
		contextId: contextId,
	}
}

// Execute executes the request
//  @return CustomFieldCreatedContextOptionsList
func (a *IssueCustomFieldOptionsAPIService) CreateCustomFieldOptionExecute(r ApiCreateCustomFieldOptionRequest) (*CustomFieldCreatedContextOptionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomFieldCreatedContextOptionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.CreateCustomFieldOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/field/{fieldId}/context/{contextId}/option"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextId"+"}", url.PathEscape(parameterValueToString(r.contextId, "contextId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkCustomFieldOptionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkCustomFieldOptionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkCustomFieldOptionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCustomFieldOptionRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	fieldId string
	contextId int64
	optionId int64
}

func (r ApiDeleteCustomFieldOptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomFieldOptionExecute(r)
}

/*
DeleteCustomFieldOption Delete custom field options (context)

Deletes a custom field option.

Options with cascading options cannot be deleted without deleting the cascading options first.

This operation works for custom field options created in Jira or the operations from this resource. **To work with issue field select list options created for Connect apps use the [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-) operations.**

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The ID of the custom field.
 @param contextId The ID of the context from which an option should be deleted.
 @param optionId The ID of the option to delete.
 @return ApiDeleteCustomFieldOptionRequest
*/
func (a *IssueCustomFieldOptionsAPIService) DeleteCustomFieldOption(ctx context.Context, fieldId string, contextId int64, optionId int64) ApiDeleteCustomFieldOptionRequest {
	return ApiDeleteCustomFieldOptionRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
		contextId: contextId,
		optionId: optionId,
	}
}

// Execute executes the request
func (a *IssueCustomFieldOptionsAPIService) DeleteCustomFieldOptionExecute(r ApiDeleteCustomFieldOptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.DeleteCustomFieldOption")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextId"+"}", url.PathEscape(parameterValueToString(r.contextId, "contextId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"optionId"+"}", url.PathEscape(parameterValueToString(r.optionId, "optionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCustomFieldOptionRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	id string
}

func (r ApiGetCustomFieldOptionRequest) Execute() (*CustomFieldOption, *http.Response, error) {
	return r.ApiService.GetCustomFieldOptionExecute(r)
}

/*
GetCustomFieldOption Get custom field option

Returns a custom field option. For example, an option in a select list.

Note that this operation **only works for issue field select list options created in Jira or using operations from the [Issue custom field options](#api-group-Issue-custom-field-options) resource**, it cannot be used with issue field select list options created by Connect apps.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** The custom field option is returned as follows:

 *  if the user has the *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
 *  if the user has the *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for at least one project the custom field is used in, and the field is visible in at least one layout the user has permission to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the custom field option.
 @return ApiGetCustomFieldOptionRequest
*/
func (a *IssueCustomFieldOptionsAPIService) GetCustomFieldOption(ctx context.Context, id string) ApiGetCustomFieldOptionRequest {
	return ApiGetCustomFieldOptionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomFieldOption
func (a *IssueCustomFieldOptionsAPIService) GetCustomFieldOptionExecute(r ApiGetCustomFieldOptionRequest) (*CustomFieldOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomFieldOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.GetCustomFieldOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/customFieldOption/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOptionsForContextRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	fieldId string
	contextId int64
	optionId *int64
	onlyOptions *bool
	startAt *int64
	maxResults *int32
}

// The ID of the option.
func (r ApiGetOptionsForContextRequest) OptionId(optionId int64) ApiGetOptionsForContextRequest {
	r.optionId = &optionId
	return r
}

// Whether only options are returned.
func (r ApiGetOptionsForContextRequest) OnlyOptions(onlyOptions bool) ApiGetOptionsForContextRequest {
	r.onlyOptions = &onlyOptions
	return r
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetOptionsForContextRequest) StartAt(startAt int64) ApiGetOptionsForContextRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetOptionsForContextRequest) MaxResults(maxResults int32) ApiGetOptionsForContextRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetOptionsForContextRequest) Execute() (*PageBeanCustomFieldContextOption, *http.Response, error) {
	return r.ApiService.GetOptionsForContextExecute(r)
}

/*
GetOptionsForContext Get custom field options (context)

Returns a [paginated](#pagination) list of all custom field option for a context. Options are returned first then cascading options, in the order they display in Jira.

This operation works for custom field options created in Jira or the operations from this resource. **To work with issue field select list options created for Connect apps use the [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-) operations.**

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). *Edit Workflow* [edit workflow permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/#Edit-Workflows)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The ID of the custom field.
 @param contextId The ID of the context.
 @return ApiGetOptionsForContextRequest
*/
func (a *IssueCustomFieldOptionsAPIService) GetOptionsForContext(ctx context.Context, fieldId string, contextId int64) ApiGetOptionsForContextRequest {
	return ApiGetOptionsForContextRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
		contextId: contextId,
	}
}

// Execute executes the request
//  @return PageBeanCustomFieldContextOption
func (a *IssueCustomFieldOptionsAPIService) GetOptionsForContextExecute(r ApiGetOptionsForContextRequest) (*PageBeanCustomFieldContextOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanCustomFieldContextOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.GetOptionsForContext")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/field/{fieldId}/context/{contextId}/option"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextId"+"}", url.PathEscape(parameterValueToString(r.contextId, "contextId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.optionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optionId", r.optionId, "form", "")
	}
	if r.onlyOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyOptions", r.onlyOptions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyOptions", defaultValue, "form", "")
		r.onlyOptions = &defaultValue
	}
	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReorderCustomFieldOptionsRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	fieldId string
	contextId int64
	orderOfCustomFieldOptions *OrderOfCustomFieldOptions
}

func (r ApiReorderCustomFieldOptionsRequest) OrderOfCustomFieldOptions(orderOfCustomFieldOptions OrderOfCustomFieldOptions) ApiReorderCustomFieldOptionsRequest {
	r.orderOfCustomFieldOptions = &orderOfCustomFieldOptions
	return r
}

func (r ApiReorderCustomFieldOptionsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ReorderCustomFieldOptionsExecute(r)
}

/*
ReorderCustomFieldOptions Reorder custom field options (context)

Changes the order of custom field options or cascading options in a context.

This operation works for custom field options created in Jira or the operations from this resource. **To work with issue field select list options created for Connect apps use the [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-) operations.**

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The ID of the custom field.
 @param contextId The ID of the context.
 @return ApiReorderCustomFieldOptionsRequest
*/
func (a *IssueCustomFieldOptionsAPIService) ReorderCustomFieldOptions(ctx context.Context, fieldId string, contextId int64) ApiReorderCustomFieldOptionsRequest {
	return ApiReorderCustomFieldOptionsRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
		contextId: contextId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueCustomFieldOptionsAPIService) ReorderCustomFieldOptionsExecute(r ApiReorderCustomFieldOptionsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.ReorderCustomFieldOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/field/{fieldId}/context/{contextId}/option/move"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextId"+"}", url.PathEscape(parameterValueToString(r.contextId, "contextId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderOfCustomFieldOptions == nil {
		return localVarReturnValue, nil, reportError("orderOfCustomFieldOptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderOfCustomFieldOptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCustomFieldOptionRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	fieldId string
	optionId int64
	contextId int64
	replaceWith *int64
	jql *string
}

// The ID of the option that will replace the currently selected option.
func (r ApiReplaceCustomFieldOptionRequest) ReplaceWith(replaceWith int64) ApiReplaceCustomFieldOptionRequest {
	r.replaceWith = &replaceWith
	return r
}

// A JQL query that specifies the issues to be updated. For example, *project&#x3D;10000*.
func (r ApiReplaceCustomFieldOptionRequest) Jql(jql string) ApiReplaceCustomFieldOptionRequest {
	r.jql = &jql
	return r
}

func (r ApiReplaceCustomFieldOptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReplaceCustomFieldOptionExecute(r)
}

/*
ReplaceCustomFieldOption Replace custom field options

Replaces the options of a custom field.

Note that this operation **only works for issue field select list options created in Jira or using operations from the [Issue custom field options](#api-group-Issue-custom-field-options) resource**, it cannot be used with issue field select list options created by Connect or Forge apps.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The ID of the custom field.
 @param optionId The ID of the option to be deselected.
 @param contextId The ID of the context.
 @return ApiReplaceCustomFieldOptionRequest
*/
func (a *IssueCustomFieldOptionsAPIService) ReplaceCustomFieldOption(ctx context.Context, fieldId string, optionId int64, contextId int64) ApiReplaceCustomFieldOptionRequest {
	return ApiReplaceCustomFieldOptionRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
		optionId: optionId,
		contextId: contextId,
	}
}

// Execute executes the request
func (a *IssueCustomFieldOptionsAPIService) ReplaceCustomFieldOptionExecute(r ApiReplaceCustomFieldOptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.ReplaceCustomFieldOption")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"optionId"+"}", url.PathEscape(parameterValueToString(r.optionId, "optionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextId"+"}", url.PathEscape(parameterValueToString(r.contextId, "contextId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.replaceWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaceWith", r.replaceWith, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 303 {
			var v TaskProgressBeanRemoveOptionFromIssuesResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCustomFieldOptionRequest struct {
	ctx context.Context
	ApiService *IssueCustomFieldOptionsAPIService
	fieldId string
	contextId int64
	bulkCustomFieldOptionUpdateRequest *BulkCustomFieldOptionUpdateRequest
}

func (r ApiUpdateCustomFieldOptionRequest) BulkCustomFieldOptionUpdateRequest(bulkCustomFieldOptionUpdateRequest BulkCustomFieldOptionUpdateRequest) ApiUpdateCustomFieldOptionRequest {
	r.bulkCustomFieldOptionUpdateRequest = &bulkCustomFieldOptionUpdateRequest
	return r
}

func (r ApiUpdateCustomFieldOptionRequest) Execute() (*CustomFieldUpdatedContextOptionsList, *http.Response, error) {
	return r.ApiService.UpdateCustomFieldOptionExecute(r)
}

/*
UpdateCustomFieldOption Update custom field options (context)

Updates the options of a custom field.

If any of the options are not found, no options are updated. Options where the values in the request match the current values aren't updated and aren't reported in the response.

Note that this operation **only works for issue field select list options created in Jira or using operations from the [Issue custom field options](#api-group-Issue-custom-field-options) resource**, it cannot be used with issue field select list options created by Connect apps.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The ID of the custom field.
 @param contextId The ID of the context.
 @return ApiUpdateCustomFieldOptionRequest
*/
func (a *IssueCustomFieldOptionsAPIService) UpdateCustomFieldOption(ctx context.Context, fieldId string, contextId int64) ApiUpdateCustomFieldOptionRequest {
	return ApiUpdateCustomFieldOptionRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
		contextId: contextId,
	}
}

// Execute executes the request
//  @return CustomFieldUpdatedContextOptionsList
func (a *IssueCustomFieldOptionsAPIService) UpdateCustomFieldOptionExecute(r ApiUpdateCustomFieldOptionRequest) (*CustomFieldUpdatedContextOptionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomFieldUpdatedContextOptionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueCustomFieldOptionsAPIService.UpdateCustomFieldOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/field/{fieldId}/context/{contextId}/option"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextId"+"}", url.PathEscape(parameterValueToString(r.contextId, "contextId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkCustomFieldOptionUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkCustomFieldOptionUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkCustomFieldOptionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
