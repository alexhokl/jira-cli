/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProjectAvatarsAPIService ProjectAvatarsAPI service
type ProjectAvatarsAPIService service

type ApiCreateProjectAvatarRequest struct {
	ctx context.Context
	ApiService *ProjectAvatarsAPIService
	projectIdOrKey string
	body *interface{}
	x *int32
	y *int32
	size *int32
}

func (r ApiCreateProjectAvatarRequest) Body(body interface{}) ApiCreateProjectAvatarRequest {
	r.body = &body
	return r
}

// The X coordinate of the top-left corner of the crop region.
func (r ApiCreateProjectAvatarRequest) X(x int32) ApiCreateProjectAvatarRequest {
	r.x = &x
	return r
}

// The Y coordinate of the top-left corner of the crop region.
func (r ApiCreateProjectAvatarRequest) Y(y int32) ApiCreateProjectAvatarRequest {
	r.y = &y
	return r
}

// The length of each side of the crop region.
func (r ApiCreateProjectAvatarRequest) Size(size int32) ApiCreateProjectAvatarRequest {
	r.size = &size
	return r
}

func (r ApiCreateProjectAvatarRequest) Execute() (*Avatar, *http.Response, error) {
	return r.ApiService.CreateProjectAvatarExecute(r)
}

/*
CreateProjectAvatar Load project avatar

Loads an avatar for a project.

Specify the avatar's local file location in the body of the request. Also, include the following headers:

 *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the request, for more information see [Special Headers](#special-request-headers).
 *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or PNG.

For example:  
`curl --request POST `

`--user email@example.com:<api_token> `

`--header 'X-Atlassian-Token: no-check' `

`--header 'Content-Type: image/< image_type>' `

`--data-binary "<@/path/to/file/with/your/avatar>" `

`--url 'https://your-domain.atlassian.net/rest/api/3/project/{projectIdOrKey}/avatar2'`

The avatar is cropped to a square. If no crop parameters are specified, the square originates at the top left of the image. The length of the square's sides is set to the smaller of the height or width of the image.

The cropped image is then used to create avatars of 16x16, 24x24, 32x32, and 48x48 in size.

After creating the avatar use [Set project avatar](#api-rest-api-3-project-projectIdOrKey-avatar-put) to set it as the project's displayed avatar.

**[Permissions](#permissions) required:** *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectIdOrKey The ID or (case-sensitive) key of the project.
 @return ApiCreateProjectAvatarRequest
*/
func (a *ProjectAvatarsAPIService) CreateProjectAvatar(ctx context.Context, projectIdOrKey string) ApiCreateProjectAvatarRequest {
	return ApiCreateProjectAvatarRequest{
		ApiService: a,
		ctx: ctx,
		projectIdOrKey: projectIdOrKey,
	}
}

// Execute executes the request
//  @return Avatar
func (a *ProjectAvatarsAPIService) CreateProjectAvatarExecute(r ApiCreateProjectAvatarRequest) (*Avatar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Avatar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAvatarsAPIService.CreateProjectAvatar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/project/{projectIdOrKey}/avatar2"
	localVarPath = strings.Replace(localVarPath, "{"+"projectIdOrKey"+"}", url.PathEscape(parameterValueToString(r.projectIdOrKey, "projectIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.x != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "x", defaultValue, "form", "")
		r.x = &defaultValue
	}
	if r.y != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "y", defaultValue, "form", "")
		r.y = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProjectAvatarRequest struct {
	ctx context.Context
	ApiService *ProjectAvatarsAPIService
	projectIdOrKey string
	id int64
}

func (r ApiDeleteProjectAvatarRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProjectAvatarExecute(r)
}

/*
DeleteProjectAvatar Delete project avatar

Deletes a custom avatar from a project. Note that system avatars cannot be deleted.

**[Permissions](#permissions) required:** *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectIdOrKey The project ID or (case-sensitive) key.
 @param id The ID of the avatar.
 @return ApiDeleteProjectAvatarRequest
*/
func (a *ProjectAvatarsAPIService) DeleteProjectAvatar(ctx context.Context, projectIdOrKey string, id int64) ApiDeleteProjectAvatarRequest {
	return ApiDeleteProjectAvatarRequest{
		ApiService: a,
		ctx: ctx,
		projectIdOrKey: projectIdOrKey,
		id: id,
	}
}

// Execute executes the request
func (a *ProjectAvatarsAPIService) DeleteProjectAvatarExecute(r ApiDeleteProjectAvatarRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAvatarsAPIService.DeleteProjectAvatar")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/project/{projectIdOrKey}/avatar/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectIdOrKey"+"}", url.PathEscape(parameterValueToString(r.projectIdOrKey, "projectIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllProjectAvatarsRequest struct {
	ctx context.Context
	ApiService *ProjectAvatarsAPIService
	projectIdOrKey string
}

func (r ApiGetAllProjectAvatarsRequest) Execute() (*ProjectAvatars, *http.Response, error) {
	return r.ApiService.GetAllProjectAvatarsExecute(r)
}

/*
GetAllProjectAvatars Get all project avatars

Returns all project avatars, grouped by system and custom avatars.

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectIdOrKey The ID or (case-sensitive) key of the project.
 @return ApiGetAllProjectAvatarsRequest
*/
func (a *ProjectAvatarsAPIService) GetAllProjectAvatars(ctx context.Context, projectIdOrKey string) ApiGetAllProjectAvatarsRequest {
	return ApiGetAllProjectAvatarsRequest{
		ApiService: a,
		ctx: ctx,
		projectIdOrKey: projectIdOrKey,
	}
}

// Execute executes the request
//  @return ProjectAvatars
func (a *ProjectAvatarsAPIService) GetAllProjectAvatarsExecute(r ApiGetAllProjectAvatarsRequest) (*ProjectAvatars, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectAvatars
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAvatarsAPIService.GetAllProjectAvatars")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/project/{projectIdOrKey}/avatars"
	localVarPath = strings.Replace(localVarPath, "{"+"projectIdOrKey"+"}", url.PathEscape(parameterValueToString(r.projectIdOrKey, "projectIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProjectAvatarRequest struct {
	ctx context.Context
	ApiService *ProjectAvatarsAPIService
	projectIdOrKey string
	avatar *Avatar
}

func (r ApiUpdateProjectAvatarRequest) Avatar(avatar Avatar) ApiUpdateProjectAvatarRequest {
	r.avatar = &avatar
	return r
}

func (r ApiUpdateProjectAvatarRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateProjectAvatarExecute(r)
}

/*
UpdateProjectAvatar Set project avatar

Sets the avatar displayed for a project.

Use [Load project avatar](#api-rest-api-3-project-projectIdOrKey-avatar2-post) to store avatars against the project, before using this operation to set the displayed avatar.

**[Permissions](#permissions) required:** *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectIdOrKey The ID or (case-sensitive) key of the project.
 @return ApiUpdateProjectAvatarRequest
*/
func (a *ProjectAvatarsAPIService) UpdateProjectAvatar(ctx context.Context, projectIdOrKey string) ApiUpdateProjectAvatarRequest {
	return ApiUpdateProjectAvatarRequest{
		ApiService: a,
		ctx: ctx,
		projectIdOrKey: projectIdOrKey,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ProjectAvatarsAPIService) UpdateProjectAvatarExecute(r ApiUpdateProjectAvatarRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAvatarsAPIService.UpdateProjectAvatar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/project/{projectIdOrKey}/avatar"
	localVarPath = strings.Replace(localVarPath, "{"+"projectIdOrKey"+"}", url.PathEscape(parameterValueToString(r.projectIdOrKey, "projectIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.avatar == nil {
		return localVarReturnValue, nil, reportError("avatar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.avatar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
