/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IssueTypeScreenSchemesAPIService IssueTypeScreenSchemesAPI service
type IssueTypeScreenSchemesAPIService service

type ApiAppendMappingsForIssueTypeScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeId string
	issueTypeScreenSchemeMappingDetails *IssueTypeScreenSchemeMappingDetails
}

func (r ApiAppendMappingsForIssueTypeScreenSchemeRequest) IssueTypeScreenSchemeMappingDetails(issueTypeScreenSchemeMappingDetails IssueTypeScreenSchemeMappingDetails) ApiAppendMappingsForIssueTypeScreenSchemeRequest {
	r.issueTypeScreenSchemeMappingDetails = &issueTypeScreenSchemeMappingDetails
	return r
}

func (r ApiAppendMappingsForIssueTypeScreenSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AppendMappingsForIssueTypeScreenSchemeExecute(r)
}

/*
AppendMappingsForIssueTypeScreenScheme Append mappings to issue type screen scheme

Appends issue type to screen scheme mappings to an issue type screen scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
 @return ApiAppendMappingsForIssueTypeScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) AppendMappingsForIssueTypeScreenScheme(ctx context.Context, issueTypeScreenSchemeId string) ApiAppendMappingsForIssueTypeScreenSchemeRequest {
	return ApiAppendMappingsForIssueTypeScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeScreenSchemeId: issueTypeScreenSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeScreenSchemesAPIService) AppendMappingsForIssueTypeScreenSchemeExecute(r ApiAppendMappingsForIssueTypeScreenSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.AppendMappingsForIssueTypeScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeScreenSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeScreenSchemeId, "issueTypeScreenSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeScreenSchemeMappingDetails == nil {
		return localVarReturnValue, nil, reportError("issueTypeScreenSchemeMappingDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeScreenSchemeMappingDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignIssueTypeScreenSchemeToProjectRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeProjectAssociation *IssueTypeScreenSchemeProjectAssociation
}

func (r ApiAssignIssueTypeScreenSchemeToProjectRequest) IssueTypeScreenSchemeProjectAssociation(issueTypeScreenSchemeProjectAssociation IssueTypeScreenSchemeProjectAssociation) ApiAssignIssueTypeScreenSchemeToProjectRequest {
	r.issueTypeScreenSchemeProjectAssociation = &issueTypeScreenSchemeProjectAssociation
	return r
}

func (r ApiAssignIssueTypeScreenSchemeToProjectRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AssignIssueTypeScreenSchemeToProjectExecute(r)
}

/*
AssignIssueTypeScreenSchemeToProject Assign issue type screen scheme to project

Assigns an issue type screen scheme to a project.

Issue type screen schemes can only be assigned to classic projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssignIssueTypeScreenSchemeToProjectRequest
*/
func (a *IssueTypeScreenSchemesAPIService) AssignIssueTypeScreenSchemeToProject(ctx context.Context) ApiAssignIssueTypeScreenSchemeToProjectRequest {
	return ApiAssignIssueTypeScreenSchemeToProjectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeScreenSchemesAPIService) AssignIssueTypeScreenSchemeToProjectExecute(r ApiAssignIssueTypeScreenSchemeToProjectRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.AssignIssueTypeScreenSchemeToProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeScreenSchemeProjectAssociation == nil {
		return localVarReturnValue, nil, reportError("issueTypeScreenSchemeProjectAssociation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeScreenSchemeProjectAssociation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIssueTypeScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeDetails *IssueTypeScreenSchemeDetails
}

// An issue type screen scheme bean.
func (r ApiCreateIssueTypeScreenSchemeRequest) IssueTypeScreenSchemeDetails(issueTypeScreenSchemeDetails IssueTypeScreenSchemeDetails) ApiCreateIssueTypeScreenSchemeRequest {
	r.issueTypeScreenSchemeDetails = &issueTypeScreenSchemeDetails
	return r
}

func (r ApiCreateIssueTypeScreenSchemeRequest) Execute() (*IssueTypeScreenSchemeId, *http.Response, error) {
	return r.ApiService.CreateIssueTypeScreenSchemeExecute(r)
}

/*
CreateIssueTypeScreenScheme Create issue type screen scheme

Creates an issue type screen scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIssueTypeScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) CreateIssueTypeScreenScheme(ctx context.Context) ApiCreateIssueTypeScreenSchemeRequest {
	return ApiCreateIssueTypeScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IssueTypeScreenSchemeId
func (a *IssueTypeScreenSchemesAPIService) CreateIssueTypeScreenSchemeExecute(r ApiCreateIssueTypeScreenSchemeRequest) (*IssueTypeScreenSchemeId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IssueTypeScreenSchemeId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.CreateIssueTypeScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeScreenSchemeDetails == nil {
		return localVarReturnValue, nil, reportError("issueTypeScreenSchemeDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeScreenSchemeDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIssueTypeScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeId string
}

func (r ApiDeleteIssueTypeScreenSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteIssueTypeScreenSchemeExecute(r)
}

/*
DeleteIssueTypeScreenScheme Delete issue type screen scheme

Deletes an issue type screen scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
 @return ApiDeleteIssueTypeScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) DeleteIssueTypeScreenScheme(ctx context.Context, issueTypeScreenSchemeId string) ApiDeleteIssueTypeScreenSchemeRequest {
	return ApiDeleteIssueTypeScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeScreenSchemeId: issueTypeScreenSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeScreenSchemesAPIService) DeleteIssueTypeScreenSchemeExecute(r ApiDeleteIssueTypeScreenSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.DeleteIssueTypeScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeScreenSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeScreenSchemeId, "issueTypeScreenSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueTypeScreenSchemeMappingsRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	startAt *int64
	maxResults *int32
	issueTypeScreenSchemeId *[]int64
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetIssueTypeScreenSchemeMappingsRequest) StartAt(startAt int64) ApiGetIssueTypeScreenSchemeMappingsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetIssueTypeScreenSchemeMappingsRequest) MaxResults(maxResults int32) ApiGetIssueTypeScreenSchemeMappingsRequest {
	r.maxResults = &maxResults
	return r
}

// The list of issue type screen scheme IDs. To include multiple issue type screen schemes, separate IDs with ampersand: &#x60;issueTypeScreenSchemeId&#x3D;10000&amp;issueTypeScreenSchemeId&#x3D;10001&#x60;.
func (r ApiGetIssueTypeScreenSchemeMappingsRequest) IssueTypeScreenSchemeId(issueTypeScreenSchemeId []int64) ApiGetIssueTypeScreenSchemeMappingsRequest {
	r.issueTypeScreenSchemeId = &issueTypeScreenSchemeId
	return r
}

func (r ApiGetIssueTypeScreenSchemeMappingsRequest) Execute() (*PageBeanIssueTypeScreenSchemeItem, *http.Response, error) {
	return r.ApiService.GetIssueTypeScreenSchemeMappingsExecute(r)
}

/*
GetIssueTypeScreenSchemeMappings Get issue type screen scheme items

Returns a [paginated](#pagination) list of issue type screen scheme items.

Only issue type screen schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueTypeScreenSchemeMappingsRequest
*/
func (a *IssueTypeScreenSchemesAPIService) GetIssueTypeScreenSchemeMappings(ctx context.Context) ApiGetIssueTypeScreenSchemeMappingsRequest {
	return ApiGetIssueTypeScreenSchemeMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanIssueTypeScreenSchemeItem
func (a *IssueTypeScreenSchemesAPIService) GetIssueTypeScreenSchemeMappingsExecute(r ApiGetIssueTypeScreenSchemeMappingsRequest) (*PageBeanIssueTypeScreenSchemeItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanIssueTypeScreenSchemeItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.GetIssueTypeScreenSchemeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.issueTypeScreenSchemeId != nil {
		t := *r.issueTypeScreenSchemeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "issueTypeScreenSchemeId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "issueTypeScreenSchemeId", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueTypeScreenSchemeProjectAssociationsRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	projectId *[]int64
	startAt *int64
	maxResults *int32
}

// The list of project IDs. To include multiple projects, separate IDs with ampersand: &#x60;projectId&#x3D;10000&amp;projectId&#x3D;10001&#x60;.
func (r ApiGetIssueTypeScreenSchemeProjectAssociationsRequest) ProjectId(projectId []int64) ApiGetIssueTypeScreenSchemeProjectAssociationsRequest {
	r.projectId = &projectId
	return r
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetIssueTypeScreenSchemeProjectAssociationsRequest) StartAt(startAt int64) ApiGetIssueTypeScreenSchemeProjectAssociationsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetIssueTypeScreenSchemeProjectAssociationsRequest) MaxResults(maxResults int32) ApiGetIssueTypeScreenSchemeProjectAssociationsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetIssueTypeScreenSchemeProjectAssociationsRequest) Execute() (*PageBeanIssueTypeScreenSchemesProjects, *http.Response, error) {
	return r.ApiService.GetIssueTypeScreenSchemeProjectAssociationsExecute(r)
}

/*
GetIssueTypeScreenSchemeProjectAssociations Get issue type screen schemes for projects

Returns a [paginated](#pagination) list of issue type screen schemes and, for each issue type screen scheme, a list of the projects that use it.

Only issue type screen schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueTypeScreenSchemeProjectAssociationsRequest
*/
func (a *IssueTypeScreenSchemesAPIService) GetIssueTypeScreenSchemeProjectAssociations(ctx context.Context) ApiGetIssueTypeScreenSchemeProjectAssociationsRequest {
	return ApiGetIssueTypeScreenSchemeProjectAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanIssueTypeScreenSchemesProjects
func (a *IssueTypeScreenSchemesAPIService) GetIssueTypeScreenSchemeProjectAssociationsExecute(r ApiGetIssueTypeScreenSchemeProjectAssociationsRequest) (*PageBeanIssueTypeScreenSchemesProjects, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanIssueTypeScreenSchemesProjects
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.GetIssueTypeScreenSchemeProjectAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	{
		t := *r.projectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueTypeScreenSchemesRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	startAt *int64
	maxResults *int32
	id *[]int64
	queryString *string
	orderBy *string
	expand *string
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetIssueTypeScreenSchemesRequest) StartAt(startAt int64) ApiGetIssueTypeScreenSchemesRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetIssueTypeScreenSchemesRequest) MaxResults(maxResults int32) ApiGetIssueTypeScreenSchemesRequest {
	r.maxResults = &maxResults
	return r
}

// The list of issue type screen scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, &#x60;id&#x3D;10000&amp;id&#x3D;10001&#x60;.
func (r ApiGetIssueTypeScreenSchemesRequest) Id(id []int64) ApiGetIssueTypeScreenSchemesRequest {
	r.id = &id
	return r
}

// String used to perform a case-insensitive partial match with issue type screen scheme name.
func (r ApiGetIssueTypeScreenSchemesRequest) QueryString(queryString string) ApiGetIssueTypeScreenSchemesRequest {
	r.queryString = &queryString
	return r
}

// [Order](#ordering) the results by a field:   *  &#x60;name&#x60; Sorts by issue type screen scheme name.  *  &#x60;id&#x60; Sorts by issue type screen scheme ID.
func (r ApiGetIssueTypeScreenSchemesRequest) OrderBy(orderBy string) ApiGetIssueTypeScreenSchemesRequest {
	r.orderBy = &orderBy
	return r
}

// Use [expand](#expansion) to include additional information in the response. This parameter accepts &#x60;projects&#x60; that, for each issue type screen schemes, returns information about the projects the issue type screen scheme is assigned to.
func (r ApiGetIssueTypeScreenSchemesRequest) Expand(expand string) ApiGetIssueTypeScreenSchemesRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssueTypeScreenSchemesRequest) Execute() (*PageBeanIssueTypeScreenScheme, *http.Response, error) {
	return r.ApiService.GetIssueTypeScreenSchemesExecute(r)
}

/*
GetIssueTypeScreenSchemes Get issue type screen schemes

Returns a [paginated](#pagination) list of issue type screen schemes.

Only issue type screen schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueTypeScreenSchemesRequest
*/
func (a *IssueTypeScreenSchemesAPIService) GetIssueTypeScreenSchemes(ctx context.Context) ApiGetIssueTypeScreenSchemesRequest {
	return ApiGetIssueTypeScreenSchemesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanIssueTypeScreenScheme
func (a *IssueTypeScreenSchemesAPIService) GetIssueTypeScreenSchemesExecute(r ApiGetIssueTypeScreenSchemesRequest) (*PageBeanIssueTypeScreenScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanIssueTypeScreenScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.GetIssueTypeScreenSchemes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.queryString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryString", r.queryString, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryString", defaultValue, "form", "")
		r.queryString = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", defaultValue, "form", "")
		r.orderBy = &defaultValue
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectsForIssueTypeScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeId int64
	startAt *int64
	maxResults *int32
	query *string
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetProjectsForIssueTypeScreenSchemeRequest) StartAt(startAt int64) ApiGetProjectsForIssueTypeScreenSchemeRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetProjectsForIssueTypeScreenSchemeRequest) MaxResults(maxResults int32) ApiGetProjectsForIssueTypeScreenSchemeRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetProjectsForIssueTypeScreenSchemeRequest) Query(query string) ApiGetProjectsForIssueTypeScreenSchemeRequest {
	r.query = &query
	return r
}

func (r ApiGetProjectsForIssueTypeScreenSchemeRequest) Execute() (*PageBeanProjectDetails, *http.Response, error) {
	return r.ApiService.GetProjectsForIssueTypeScreenSchemeExecute(r)
}

/*
GetProjectsForIssueTypeScreenScheme Get issue type screen scheme projects

Returns a [paginated](#pagination) list of projects associated with an issue type screen scheme.

Only company-managed projects associated with an issue type screen scheme are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
 @return ApiGetProjectsForIssueTypeScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) GetProjectsForIssueTypeScreenScheme(ctx context.Context, issueTypeScreenSchemeId int64) ApiGetProjectsForIssueTypeScreenSchemeRequest {
	return ApiGetProjectsForIssueTypeScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeScreenSchemeId: issueTypeScreenSchemeId,
	}
}

// Execute executes the request
//  @return PageBeanProjectDetails
func (a *IssueTypeScreenSchemesAPIService) GetProjectsForIssueTypeScreenSchemeExecute(r ApiGetProjectsForIssueTypeScreenSchemeRequest) (*PageBeanProjectDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanProjectDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.GetProjectsForIssueTypeScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/project"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeScreenSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeScreenSchemeId, "issueTypeScreenSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", defaultValue, "form", "")
		r.query = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveMappingsFromIssueTypeScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeId string
	issueTypeIds *IssueTypeIds
}

func (r ApiRemoveMappingsFromIssueTypeScreenSchemeRequest) IssueTypeIds(issueTypeIds IssueTypeIds) ApiRemoveMappingsFromIssueTypeScreenSchemeRequest {
	r.issueTypeIds = &issueTypeIds
	return r
}

func (r ApiRemoveMappingsFromIssueTypeScreenSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.RemoveMappingsFromIssueTypeScreenSchemeExecute(r)
}

/*
RemoveMappingsFromIssueTypeScreenScheme Remove mappings from issue type screen scheme

Removes issue type to screen scheme mappings from an issue type screen scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
 @return ApiRemoveMappingsFromIssueTypeScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) RemoveMappingsFromIssueTypeScreenScheme(ctx context.Context, issueTypeScreenSchemeId string) ApiRemoveMappingsFromIssueTypeScreenSchemeRequest {
	return ApiRemoveMappingsFromIssueTypeScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeScreenSchemeId: issueTypeScreenSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeScreenSchemesAPIService) RemoveMappingsFromIssueTypeScreenSchemeExecute(r ApiRemoveMappingsFromIssueTypeScreenSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.RemoveMappingsFromIssueTypeScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeScreenSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeScreenSchemeId, "issueTypeScreenSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeIds == nil {
		return localVarReturnValue, nil, reportError("issueTypeIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeIds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefaultScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeId string
	updateDefaultScreenScheme *UpdateDefaultScreenScheme
}

func (r ApiUpdateDefaultScreenSchemeRequest) UpdateDefaultScreenScheme(updateDefaultScreenScheme UpdateDefaultScreenScheme) ApiUpdateDefaultScreenSchemeRequest {
	r.updateDefaultScreenScheme = &updateDefaultScreenScheme
	return r
}

func (r ApiUpdateDefaultScreenSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateDefaultScreenSchemeExecute(r)
}

/*
UpdateDefaultScreenScheme Update issue type screen scheme default screen scheme

Updates the default screen scheme of an issue type screen scheme. The default screen scheme is used for all unmapped issue types.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
 @return ApiUpdateDefaultScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) UpdateDefaultScreenScheme(ctx context.Context, issueTypeScreenSchemeId string) ApiUpdateDefaultScreenSchemeRequest {
	return ApiUpdateDefaultScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeScreenSchemeId: issueTypeScreenSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeScreenSchemesAPIService) UpdateDefaultScreenSchemeExecute(r ApiUpdateDefaultScreenSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.UpdateDefaultScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/default"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeScreenSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeScreenSchemeId, "issueTypeScreenSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDefaultScreenScheme == nil {
		return localVarReturnValue, nil, reportError("updateDefaultScreenScheme is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDefaultScreenScheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIssueTypeScreenSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeScreenSchemesAPIService
	issueTypeScreenSchemeId string
	issueTypeScreenSchemeUpdateDetails *IssueTypeScreenSchemeUpdateDetails
}

// The issue type screen scheme update details.
func (r ApiUpdateIssueTypeScreenSchemeRequest) IssueTypeScreenSchemeUpdateDetails(issueTypeScreenSchemeUpdateDetails IssueTypeScreenSchemeUpdateDetails) ApiUpdateIssueTypeScreenSchemeRequest {
	r.issueTypeScreenSchemeUpdateDetails = &issueTypeScreenSchemeUpdateDetails
	return r
}

func (r ApiUpdateIssueTypeScreenSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateIssueTypeScreenSchemeExecute(r)
}

/*
UpdateIssueTypeScreenScheme Update issue type screen scheme

Updates an issue type screen scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
 @return ApiUpdateIssueTypeScreenSchemeRequest
*/
func (a *IssueTypeScreenSchemesAPIService) UpdateIssueTypeScreenScheme(ctx context.Context, issueTypeScreenSchemeId string) ApiUpdateIssueTypeScreenSchemeRequest {
	return ApiUpdateIssueTypeScreenSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeScreenSchemeId: issueTypeScreenSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeScreenSchemesAPIService) UpdateIssueTypeScreenSchemeExecute(r ApiUpdateIssueTypeScreenSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeScreenSchemesAPIService.UpdateIssueTypeScreenScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeScreenSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeScreenSchemeId, "issueTypeScreenSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeScreenSchemeUpdateDetails == nil {
		return localVarReturnValue, nil, reportError("issueTypeScreenSchemeUpdateDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeScreenSchemeUpdateDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
