/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// IssueWorklogsAPIService IssueWorklogsAPI service
type IssueWorklogsAPIService service

type ApiAddWorklogRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	worklog *Worklog
	notifyUsers *bool
	adjustEstimate *string
	newEstimate *string
	reduceBy *string
	expand *string
	overrideEditableFlag *bool
}

func (r ApiAddWorklogRequest) Worklog(worklog Worklog) ApiAddWorklogRequest {
	r.worklog = &worklog
	return r
}

// Whether users watching the issue are notified by email.
func (r ApiAddWorklogRequest) NotifyUsers(notifyUsers bool) ApiAddWorklogRequest {
	r.notifyUsers = &notifyUsers
	return r
}

// Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;manual&#x60; Reduces the estimate by amount specified in &#x60;reduceBy&#x60;.  *  &#x60;auto&#x60; Reduces the estimate by the value of &#x60;timeSpent&#x60; in the worklog.
func (r ApiAddWorklogRequest) AdjustEstimate(adjustEstimate string) ApiAddWorklogRequest {
	r.adjustEstimate = &adjustEstimate
	return r
}

// The value to set as the issue&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;.
func (r ApiAddWorklogRequest) NewEstimate(newEstimate string) ApiAddWorklogRequest {
	r.newEstimate = &newEstimate
	return r
}

// The amount to reduce the issue&#39;s remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;manual&#x60;.
func (r ApiAddWorklogRequest) ReduceBy(reduceBy string) ApiAddWorklogRequest {
	r.reduceBy = &reduceBy
	return r
}

// Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts &#x60;properties&#x60;, which returns worklog properties.
func (r ApiAddWorklogRequest) Expand(expand string) ApiAddWorklogRequest {
	r.expand = &expand
	return r
}

// Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
func (r ApiAddWorklogRequest) OverrideEditableFlag(overrideEditableFlag bool) ApiAddWorklogRequest {
	r.overrideEditableFlag = &overrideEditableFlag
	return r
}

func (r ApiAddWorklogRequest) Execute() (*Worklog, *http.Response, error) {
	return r.ApiService.AddWorklogExecute(r)
}

/*
AddWorklog Add worklog

Adds a worklog to an issue.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

This operation can be accessed anonymously.

**[Permissions](#permissions) required:**

 *  *Browse projects* and *Work on issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key the issue.
 @return ApiAddWorklogRequest
*/
func (a *IssueWorklogsAPIService) AddWorklog(ctx context.Context, issueIdOrKey string) ApiAddWorklogRequest {
	return ApiAddWorklogRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
//  @return Worklog
func (a *IssueWorklogsAPIService) AddWorklogExecute(r ApiAddWorklogRequest) (*Worklog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Worklog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.AddWorklog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.worklog == nil {
		return localVarReturnValue, nil, reportError("worklog is required and must be specified")
	}

	if r.notifyUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyUsers", r.notifyUsers, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyUsers", defaultValue, "form", "")
		r.notifyUsers = &defaultValue
	}
	if r.adjustEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", r.adjustEstimate, "form", "")
	} else {
		var defaultValue string = "auto"
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", defaultValue, "form", "")
		r.adjustEstimate = &defaultValue
	}
	if r.newEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newEstimate", r.newEstimate, "form", "")
	}
	if r.reduceBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduceBy", r.reduceBy, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	if r.overrideEditableFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", r.overrideEditableFlag, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", defaultValue, "form", "")
		r.overrideEditableFlag = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.worklog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkDeleteWorklogsRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	worklogIdsRequestBean *WorklogIdsRequestBean
	adjustEstimate *string
	overrideEditableFlag *bool
}

// A JSON object containing a list of worklog IDs.
func (r ApiBulkDeleteWorklogsRequest) WorklogIdsRequestBean(worklogIdsRequestBean WorklogIdsRequestBean) ApiBulkDeleteWorklogsRequest {
	r.worklogIdsRequestBean = &worklogIdsRequestBean
	return r
}

// Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;auto&#x60; Reduces the estimate by the aggregate value of &#x60;timeSpent&#x60; across all worklogs being deleted.
func (r ApiBulkDeleteWorklogsRequest) AdjustEstimate(adjustEstimate string) ApiBulkDeleteWorklogsRequest {
	r.adjustEstimate = &adjustEstimate
	return r
}

// Whether the work log entries should be removed to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
func (r ApiBulkDeleteWorklogsRequest) OverrideEditableFlag(overrideEditableFlag bool) ApiBulkDeleteWorklogsRequest {
	r.overrideEditableFlag = &overrideEditableFlag
	return r
}

func (r ApiBulkDeleteWorklogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkDeleteWorklogsExecute(r)
}

/*
BulkDeleteWorklogs Bulk delete worklogs

Deletes a list of worklogs from an issue. This is an experimental API with limitations:

 *  You can't delete more than 5000 worklogs at once.
 *  No notifications will be sent for deleted worklogs.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

**[Permissions](#permissions) required:**

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
 *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog.
 *  If any worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the issue.
 @return ApiBulkDeleteWorklogsRequest
*/
func (a *IssueWorklogsAPIService) BulkDeleteWorklogs(ctx context.Context, issueIdOrKey string) ApiBulkDeleteWorklogsRequest {
	return ApiBulkDeleteWorklogsRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
func (a *IssueWorklogsAPIService) BulkDeleteWorklogsExecute(r ApiBulkDeleteWorklogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.BulkDeleteWorklogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.worklogIdsRequestBean == nil {
		return nil, reportError("worklogIdsRequestBean is required and must be specified")
	}

	if r.adjustEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", r.adjustEstimate, "form", "")
	} else {
		var defaultValue string = "auto"
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", defaultValue, "form", "")
		r.adjustEstimate = &defaultValue
	}
	if r.overrideEditableFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", r.overrideEditableFlag, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", defaultValue, "form", "")
		r.overrideEditableFlag = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.worklogIdsRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkMoveWorklogsRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	worklogsMoveRequestBean *WorklogsMoveRequestBean
	adjustEstimate *string
	overrideEditableFlag *bool
}

// A JSON object containing a list of worklog IDs and the ID or key of the destination issue.
func (r ApiBulkMoveWorklogsRequest) WorklogsMoveRequestBean(worklogsMoveRequestBean WorklogsMoveRequestBean) ApiBulkMoveWorklogsRequest {
	r.worklogsMoveRequestBean = &worklogsMoveRequestBean
	return r
}

// Defines how to update the issues&#39; time estimate, the options are:   *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;auto&#x60; Reduces the estimate by the aggregate value of &#x60;timeSpent&#x60; across all worklogs being moved in the source issue, and increases it in the destination issue.
func (r ApiBulkMoveWorklogsRequest) AdjustEstimate(adjustEstimate string) ApiBulkMoveWorklogsRequest {
	r.adjustEstimate = &adjustEstimate
	return r
}

// Whether the work log entry should be moved to and from the issues even if the issues are not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
func (r ApiBulkMoveWorklogsRequest) OverrideEditableFlag(overrideEditableFlag bool) ApiBulkMoveWorklogsRequest {
	r.overrideEditableFlag = &overrideEditableFlag
	return r
}

func (r ApiBulkMoveWorklogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkMoveWorklogsExecute(r)
}

/*
BulkMoveWorklogs Bulk move worklogs

Moves a list of worklogs from one issue to another. This is an experimental API with several limitations:

 *  You can't move more than 5000 worklogs at once.
 *  You can't move worklogs containing an attachment.
 *  You can't move worklogs restricted by project roles.
 *  No notifications will be sent for moved worklogs.
 *  No webhooks or events will be sent for moved worklogs.
 *  No issue history will be recorded for moved worklogs.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

**[Permissions](#permissions) required:**

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the projects containing the source and destination issues.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
 *  *Delete all worklogs* [project permission](https://confluence.atlassian.com/x/yodKLg)
 *  *Work on issues* [project permission](https://confluence.atlassian.com/x/yodKLg) to log work on an issue, that is to create a worklog entry, if time tracking is enabled. This permission is required as a prerequisite for applying the other time-tracking permissions
 *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey
 @return ApiBulkMoveWorklogsRequest
*/
func (a *IssueWorklogsAPIService) BulkMoveWorklogs(ctx context.Context, issueIdOrKey string) ApiBulkMoveWorklogsRequest {
	return ApiBulkMoveWorklogsRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
func (a *IssueWorklogsAPIService) BulkMoveWorklogsExecute(r ApiBulkMoveWorklogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.BulkMoveWorklogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog/move"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.worklogsMoveRequestBean == nil {
		return nil, reportError("worklogsMoveRequestBean is required and must be specified")
	}

	if r.adjustEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", r.adjustEstimate, "form", "")
	} else {
		var defaultValue string = "auto"
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", defaultValue, "form", "")
		r.adjustEstimate = &defaultValue
	}
	if r.overrideEditableFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", r.overrideEditableFlag, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", defaultValue, "form", "")
		r.overrideEditableFlag = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.worklogsMoveRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWorklogRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	id string
	notifyUsers *bool
	adjustEstimate *string
	newEstimate *string
	increaseBy *string
	overrideEditableFlag *bool
}

// Whether users watching the issue are notified by email.
func (r ApiDeleteWorklogRequest) NotifyUsers(notifyUsers bool) ApiDeleteWorklogRequest {
	r.notifyUsers = &notifyUsers
	return r
}

// Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;manual&#x60; Increases the estimate by amount specified in &#x60;increaseBy&#x60;.  *  &#x60;auto&#x60; Reduces the estimate by the value of &#x60;timeSpent&#x60; in the worklog.
func (r ApiDeleteWorklogRequest) AdjustEstimate(adjustEstimate string) ApiDeleteWorklogRequest {
	r.adjustEstimate = &adjustEstimate
	return r
}

// The value to set as the issue&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;.
func (r ApiDeleteWorklogRequest) NewEstimate(newEstimate string) ApiDeleteWorklogRequest {
	r.newEstimate = &newEstimate
	return r
}

// The amount to increase the issue&#39;s remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;manual&#x60;.
func (r ApiDeleteWorklogRequest) IncreaseBy(increaseBy string) ApiDeleteWorklogRequest {
	r.increaseBy = &increaseBy
	return r
}

// Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
func (r ApiDeleteWorklogRequest) OverrideEditableFlag(overrideEditableFlag bool) ApiDeleteWorklogRequest {
	r.overrideEditableFlag = &overrideEditableFlag
	return r
}

func (r ApiDeleteWorklogRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWorklogExecute(r)
}

/*
DeleteWorklog Delete worklog

Deletes a worklog from an issue.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

This operation can be accessed anonymously.

**[Permissions](#permissions) required:**

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
 *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog or *Delete own worklogs* to delete worklogs created by the user,
 *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the issue.
 @param id The ID of the worklog.
 @return ApiDeleteWorklogRequest
*/
func (a *IssueWorklogsAPIService) DeleteWorklog(ctx context.Context, issueIdOrKey string, id string) ApiDeleteWorklogRequest {
	return ApiDeleteWorklogRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
		id: id,
	}
}

// Execute executes the request
func (a *IssueWorklogsAPIService) DeleteWorklogExecute(r ApiDeleteWorklogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.DeleteWorklog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.notifyUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyUsers", r.notifyUsers, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyUsers", defaultValue, "form", "")
		r.notifyUsers = &defaultValue
	}
	if r.adjustEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", r.adjustEstimate, "form", "")
	} else {
		var defaultValue string = "auto"
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", defaultValue, "form", "")
		r.adjustEstimate = &defaultValue
	}
	if r.newEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newEstimate", r.newEstimate, "form", "")
	}
	if r.increaseBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "increaseBy", r.increaseBy, "form", "")
	}
	if r.overrideEditableFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", r.overrideEditableFlag, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", defaultValue, "form", "")
		r.overrideEditableFlag = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIdsOfWorklogsDeletedSinceRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	since *int64
}

// The date and time, as a UNIX timestamp in milliseconds, after which deleted worklogs are returned.
func (r ApiGetIdsOfWorklogsDeletedSinceRequest) Since(since int64) ApiGetIdsOfWorklogsDeletedSinceRequest {
	r.since = &since
	return r
}

func (r ApiGetIdsOfWorklogsDeletedSinceRequest) Execute() (*ChangedWorklogs, *http.Response, error) {
	return r.ApiService.GetIdsOfWorklogsDeletedSinceExecute(r)
}

/*
GetIdsOfWorklogsDeletedSince Get IDs of deleted worklogs

Returns a list of IDs and delete timestamps for worklogs deleted after a date and time.

This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, `until` indicates the timestamp of the youngest item on the page. Also, `nextPage` provides the URL for the next page of worklogs. The `lastPage` parameter is set to true on the last page of worklogs.

This resource does not return worklogs deleted during the minute preceding the request.

**[Permissions](#permissions) required:** Permission to access Jira.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIdsOfWorklogsDeletedSinceRequest
*/
func (a *IssueWorklogsAPIService) GetIdsOfWorklogsDeletedSince(ctx context.Context) ApiGetIdsOfWorklogsDeletedSinceRequest {
	return ApiGetIdsOfWorklogsDeletedSinceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedWorklogs
func (a *IssueWorklogsAPIService) GetIdsOfWorklogsDeletedSinceExecute(r ApiGetIdsOfWorklogsDeletedSinceRequest) (*ChangedWorklogs, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedWorklogs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.GetIdsOfWorklogsDeletedSince")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/worklog/deleted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", defaultValue, "form", "")
		r.since = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIdsOfWorklogsModifiedSinceRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	since *int64
	expand *string
}

// The date and time, as a UNIX timestamp in milliseconds, after which updated worklogs are returned.
func (r ApiGetIdsOfWorklogsModifiedSinceRequest) Since(since int64) ApiGetIdsOfWorklogsModifiedSinceRequest {
	r.since = &since
	return r
}

// Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60; that returns the properties of each worklog.
func (r ApiGetIdsOfWorklogsModifiedSinceRequest) Expand(expand string) ApiGetIdsOfWorklogsModifiedSinceRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIdsOfWorklogsModifiedSinceRequest) Execute() (*ChangedWorklogs, *http.Response, error) {
	return r.ApiService.GetIdsOfWorklogsModifiedSinceExecute(r)
}

/*
GetIdsOfWorklogsModifiedSince Get IDs of updated worklogs

Returns a list of IDs and update timestamps for worklogs updated after a date and time.

This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, `until` indicates the timestamp of the youngest item on the page. Also, `nextPage` provides the URL for the next page of worklogs. The `lastPage` parameter is set to true on the last page of worklogs.

This resource does not return worklogs updated during the minute preceding the request.

**[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:

 *  the worklog is set as *Viewable by All Users*.
 *  the user is a member of a project role or group with permission to view the worklog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIdsOfWorklogsModifiedSinceRequest
*/
func (a *IssueWorklogsAPIService) GetIdsOfWorklogsModifiedSince(ctx context.Context) ApiGetIdsOfWorklogsModifiedSinceRequest {
	return ApiGetIdsOfWorklogsModifiedSinceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedWorklogs
func (a *IssueWorklogsAPIService) GetIdsOfWorklogsModifiedSinceExecute(r ApiGetIdsOfWorklogsModifiedSinceRequest) (*ChangedWorklogs, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedWorklogs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.GetIdsOfWorklogsModifiedSince")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/worklog/updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", defaultValue, "form", "")
		r.since = &defaultValue
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueWorklogRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	startAt *int64
	maxResults *int32
	startedAfter *int64
	startedBefore *int64
	expand *string
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetIssueWorklogRequest) StartAt(startAt int64) ApiGetIssueWorklogRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetIssueWorklogRequest) MaxResults(maxResults int32) ApiGetIssueWorklogRequest {
	r.maxResults = &maxResults
	return r
}

// The worklog start date and time, as a UNIX timestamp in milliseconds, after which worklogs are returned.
func (r ApiGetIssueWorklogRequest) StartedAfter(startedAfter int64) ApiGetIssueWorklogRequest {
	r.startedAfter = &startedAfter
	return r
}

// The worklog start date and time, as a UNIX timestamp in milliseconds, before which worklogs are returned.
func (r ApiGetIssueWorklogRequest) StartedBefore(startedBefore int64) ApiGetIssueWorklogRequest {
	r.startedBefore = &startedBefore
	return r
}

// Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts&#x60;properties&#x60;, which returns worklog properties.
func (r ApiGetIssueWorklogRequest) Expand(expand string) ApiGetIssueWorklogRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssueWorklogRequest) Execute() (*PageOfWorklogs, *http.Response, error) {
	return r.ApiService.GetIssueWorklogExecute(r)
}

/*
GetIssueWorklog Get issue worklogs

Returns worklogs for an issue (ordered by created time), starting from the oldest worklog or from the worklog started on or after a date and time.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

This operation can be accessed anonymously.

**[Permissions](#permissions) required:** Workloads are only returned where the user has:

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
 *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the issue.
 @return ApiGetIssueWorklogRequest
*/
func (a *IssueWorklogsAPIService) GetIssueWorklog(ctx context.Context, issueIdOrKey string) ApiGetIssueWorklogRequest {
	return ApiGetIssueWorklogRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
//  @return PageOfWorklogs
func (a *IssueWorklogsAPIService) GetIssueWorklogExecute(r ApiGetIssueWorklogRequest) (*PageOfWorklogs, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageOfWorklogs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.GetIssueWorklog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 5000
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "form", "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorklogRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	id string
	expand *string
}

// Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts  &#x60;properties&#x60;, which returns worklog properties.
func (r ApiGetWorklogRequest) Expand(expand string) ApiGetWorklogRequest {
	r.expand = &expand
	return r
}

func (r ApiGetWorklogRequest) Execute() (*Worklog, *http.Response, error) {
	return r.ApiService.GetWorklogExecute(r)
}

/*
GetWorklog Get worklog

Returns a worklog.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

This operation can be accessed anonymously.

**[Permissions](#permissions) required:**

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
 *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the issue.
 @param id The ID of the worklog.
 @return ApiGetWorklogRequest
*/
func (a *IssueWorklogsAPIService) GetWorklog(ctx context.Context, issueIdOrKey string, id string) ApiGetWorklogRequest {
	return ApiGetWorklogRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
		id: id,
	}
}

// Execute executes the request
//  @return Worklog
func (a *IssueWorklogsAPIService) GetWorklogExecute(r ApiGetWorklogRequest) (*Worklog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Worklog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.GetWorklog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorklogsForIdsRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	worklogIdsRequestBean *WorklogIdsRequestBean
	expand *string
}

// A JSON object containing a list of worklog IDs.
func (r ApiGetWorklogsForIdsRequest) WorklogIdsRequestBean(worklogIdsRequestBean WorklogIdsRequestBean) ApiGetWorklogsForIdsRequest {
	r.worklogIdsRequestBean = &worklogIdsRequestBean
	return r
}

// Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60; that returns the properties of each worklog.
func (r ApiGetWorklogsForIdsRequest) Expand(expand string) ApiGetWorklogsForIdsRequest {
	r.expand = &expand
	return r
}

func (r ApiGetWorklogsForIdsRequest) Execute() ([]Worklog, *http.Response, error) {
	return r.ApiService.GetWorklogsForIdsExecute(r)
}

/*
GetWorklogsForIds Get worklogs

Returns worklog details for a list of worklog IDs.

The returned list of worklogs is limited to 1000 items.

**[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:

 *  the worklog is set as *Viewable by All Users*.
 *  the user is a member of a project role or group with permission to view the worklog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWorklogsForIdsRequest
*/
func (a *IssueWorklogsAPIService) GetWorklogsForIds(ctx context.Context) ApiGetWorklogsForIdsRequest {
	return ApiGetWorklogsForIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Worklog
func (a *IssueWorklogsAPIService) GetWorklogsForIdsExecute(r ApiGetWorklogsForIdsRequest) ([]Worklog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Worklog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.GetWorklogsForIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/worklog/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.worklogIdsRequestBean == nil {
		return localVarReturnValue, nil, reportError("worklogIdsRequestBean is required and must be specified")
	}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.worklogIdsRequestBean
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWorklogRequest struct {
	ctx context.Context
	ApiService *IssueWorklogsAPIService
	issueIdOrKey string
	id string
	worklog *Worklog
	notifyUsers *bool
	adjustEstimate *string
	newEstimate *string
	expand *string
	overrideEditableFlag *bool
}

func (r ApiUpdateWorklogRequest) Worklog(worklog Worklog) ApiUpdateWorklogRequest {
	r.worklog = &worklog
	return r
}

// Whether users watching the issue are notified by email.
func (r ApiUpdateWorklogRequest) NotifyUsers(notifyUsers bool) ApiUpdateWorklogRequest {
	r.notifyUsers = &notifyUsers
	return r
}

// Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;auto&#x60; Updates the estimate by the difference between the original and updated value of &#x60;timeSpent&#x60; or &#x60;timeSpentSeconds&#x60;.
func (r ApiUpdateWorklogRequest) AdjustEstimate(adjustEstimate string) ApiUpdateWorklogRequest {
	r.adjustEstimate = &adjustEstimate
	return r
}

// The value to set as the issue&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;.
func (r ApiUpdateWorklogRequest) NewEstimate(newEstimate string) ApiUpdateWorklogRequest {
	r.newEstimate = &newEstimate
	return r
}

// Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60;, which returns worklog properties.
func (r ApiUpdateWorklogRequest) Expand(expand string) ApiUpdateWorklogRequest {
	r.expand = &expand
	return r
}

// Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
func (r ApiUpdateWorklogRequest) OverrideEditableFlag(overrideEditableFlag bool) ApiUpdateWorklogRequest {
	r.overrideEditableFlag = &overrideEditableFlag
	return r
}

func (r ApiUpdateWorklogRequest) Execute() (*Worklog, *http.Response, error) {
	return r.ApiService.UpdateWorklogExecute(r)
}

/*
UpdateWorklog Update worklog

Updates a worklog.

Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).

This operation can be accessed anonymously.

**[Permissions](#permissions) required:**

 *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
 *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
 *  *Edit all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to update any worklog or *Edit own worklogs* to update worklogs created by the user.
 *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key the issue.
 @param id The ID of the worklog.
 @return ApiUpdateWorklogRequest
*/
func (a *IssueWorklogsAPIService) UpdateWorklog(ctx context.Context, issueIdOrKey string, id string) ApiUpdateWorklogRequest {
	return ApiUpdateWorklogRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
		id: id,
	}
}

// Execute executes the request
//  @return Worklog
func (a *IssueWorklogsAPIService) UpdateWorklogExecute(r ApiUpdateWorklogRequest) (*Worklog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Worklog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueWorklogsAPIService.UpdateWorklog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.worklog == nil {
		return localVarReturnValue, nil, reportError("worklog is required and must be specified")
	}

	if r.notifyUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyUsers", r.notifyUsers, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyUsers", defaultValue, "form", "")
		r.notifyUsers = &defaultValue
	}
	if r.adjustEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", r.adjustEstimate, "form", "")
	} else {
		var defaultValue string = "auto"
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustEstimate", defaultValue, "form", "")
		r.adjustEstimate = &defaultValue
	}
	if r.newEstimate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newEstimate", r.newEstimate, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	if r.overrideEditableFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", r.overrideEditableFlag, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideEditableFlag", defaultValue, "form", "")
		r.overrideEditableFlag = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.worklog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
