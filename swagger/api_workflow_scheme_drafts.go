/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// WorkflowSchemeDraftsAPIService WorkflowSchemeDraftsAPI service
type WorkflowSchemeDraftsAPIService service

type ApiCreateWorkflowSchemeDraftFromParentRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
}

func (r ApiCreateWorkflowSchemeDraftFromParentRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.CreateWorkflowSchemeDraftFromParentExecute(r)
}

/*
CreateWorkflowSchemeDraftFromParent Create draft workflow scheme

Create a draft workflow scheme from an active workflow scheme, by copying the active workflow scheme. Note that an active workflow scheme can only have one draft workflow scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the active workflow scheme that the draft is created from.
 @return ApiCreateWorkflowSchemeDraftFromParentRequest
*/
func (a *WorkflowSchemeDraftsAPIService) CreateWorkflowSchemeDraftFromParent(ctx context.Context, id int64) ApiCreateWorkflowSchemeDraftFromParentRequest {
	return ApiCreateWorkflowSchemeDraftFromParentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) CreateWorkflowSchemeDraftFromParentExecute(r ApiCreateWorkflowSchemeDraftFromParentRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.CreateWorkflowSchemeDraftFromParent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/createdraft"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDraftDefaultWorkflowRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
}

func (r ApiDeleteDraftDefaultWorkflowRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.DeleteDraftDefaultWorkflowExecute(r)
}

/*
DeleteDraftDefaultWorkflow Delete draft default workflow

Resets the default workflow for a workflow scheme's draft. That is, the default workflow is set to Jira's system workflow (the *jira* workflow).

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiDeleteDraftDefaultWorkflowRequest
*/
func (a *WorkflowSchemeDraftsAPIService) DeleteDraftDefaultWorkflow(ctx context.Context, id int64) ApiDeleteDraftDefaultWorkflowRequest {
	return ApiDeleteDraftDefaultWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) DeleteDraftDefaultWorkflowExecute(r ApiDeleteDraftDefaultWorkflowRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.DeleteDraftDefaultWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/default"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDraftWorkflowMappingRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	workflowName *string
}

// The name of the workflow.
func (r ApiDeleteDraftWorkflowMappingRequest) WorkflowName(workflowName string) ApiDeleteDraftWorkflowMappingRequest {
	r.workflowName = &workflowName
	return r
}

func (r ApiDeleteDraftWorkflowMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDraftWorkflowMappingExecute(r)
}

/*
DeleteDraftWorkflowMapping Delete issue types for workflow in draft workflow scheme

Deletes the workflow-issue type mapping for a workflow in a workflow scheme's draft.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiDeleteDraftWorkflowMappingRequest
*/
func (a *WorkflowSchemeDraftsAPIService) DeleteDraftWorkflowMapping(ctx context.Context, id int64) ApiDeleteDraftWorkflowMappingRequest {
	return ApiDeleteDraftWorkflowMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *WorkflowSchemeDraftsAPIService) DeleteDraftWorkflowMappingExecute(r ApiDeleteDraftWorkflowMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.DeleteDraftWorkflowMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workflowName == nil {
		return nil, reportError("workflowName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "workflowName", r.workflowName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWorkflowSchemeDraftRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
}

func (r ApiDeleteWorkflowSchemeDraftRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWorkflowSchemeDraftExecute(r)
}

/*
DeleteWorkflowSchemeDraft Delete draft workflow scheme

Deletes a draft workflow scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the active workflow scheme that the draft was created from.
 @return ApiDeleteWorkflowSchemeDraftRequest
*/
func (a *WorkflowSchemeDraftsAPIService) DeleteWorkflowSchemeDraft(ctx context.Context, id int64) ApiDeleteWorkflowSchemeDraftRequest {
	return ApiDeleteWorkflowSchemeDraftRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *WorkflowSchemeDraftsAPIService) DeleteWorkflowSchemeDraftExecute(r ApiDeleteWorkflowSchemeDraftRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.DeleteWorkflowSchemeDraft")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWorkflowSchemeDraftIssueTypeRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	issueType string
}

func (r ApiDeleteWorkflowSchemeDraftIssueTypeRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.DeleteWorkflowSchemeDraftIssueTypeExecute(r)
}

/*
DeleteWorkflowSchemeDraftIssueType Delete workflow for issue type in draft workflow scheme

Deletes the issue type-workflow mapping for an issue type in a workflow scheme's draft.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @param issueType The ID of the issue type.
 @return ApiDeleteWorkflowSchemeDraftIssueTypeRequest
*/
func (a *WorkflowSchemeDraftsAPIService) DeleteWorkflowSchemeDraftIssueType(ctx context.Context, id int64, issueType string) ApiDeleteWorkflowSchemeDraftIssueTypeRequest {
	return ApiDeleteWorkflowSchemeDraftIssueTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		issueType: issueType,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) DeleteWorkflowSchemeDraftIssueTypeExecute(r ApiDeleteWorkflowSchemeDraftIssueTypeRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.DeleteWorkflowSchemeDraftIssueType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issueType"+"}", url.PathEscape(parameterValueToString(r.issueType, "issueType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDraftDefaultWorkflowRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
}

func (r ApiGetDraftDefaultWorkflowRequest) Execute() (*DefaultWorkflow, *http.Response, error) {
	return r.ApiService.GetDraftDefaultWorkflowExecute(r)
}

/*
GetDraftDefaultWorkflow Get draft default workflow

Returns the default workflow for a workflow scheme's draft. The default workflow is the workflow that is assigned any issue types that have not been mapped to any other workflow. The default workflow has *All Unassigned Issue Types* listed in its issue types for the workflow scheme in Jira.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiGetDraftDefaultWorkflowRequest
*/
func (a *WorkflowSchemeDraftsAPIService) GetDraftDefaultWorkflow(ctx context.Context, id int64) ApiGetDraftDefaultWorkflowRequest {
	return ApiGetDraftDefaultWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DefaultWorkflow
func (a *WorkflowSchemeDraftsAPIService) GetDraftDefaultWorkflowExecute(r ApiGetDraftDefaultWorkflowRequest) (*DefaultWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.GetDraftDefaultWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/default"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDraftWorkflowRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	workflowName *string
}

// The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.
func (r ApiGetDraftWorkflowRequest) WorkflowName(workflowName string) ApiGetDraftWorkflowRequest {
	r.workflowName = &workflowName
	return r
}

func (r ApiGetDraftWorkflowRequest) Execute() (*IssueTypesWorkflowMapping, *http.Response, error) {
	return r.ApiService.GetDraftWorkflowExecute(r)
}

/*
GetDraftWorkflow Get issue types for workflows in draft workflow scheme

Returns the workflow-issue type mappings for a workflow scheme's draft.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiGetDraftWorkflowRequest
*/
func (a *WorkflowSchemeDraftsAPIService) GetDraftWorkflow(ctx context.Context, id int64) ApiGetDraftWorkflowRequest {
	return ApiGetDraftWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IssueTypesWorkflowMapping
func (a *WorkflowSchemeDraftsAPIService) GetDraftWorkflowExecute(r ApiGetDraftWorkflowRequest) (*IssueTypesWorkflowMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IssueTypesWorkflowMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.GetDraftWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workflowName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workflowName", r.workflowName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkflowSchemeDraftRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
}

func (r ApiGetWorkflowSchemeDraftRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.GetWorkflowSchemeDraftExecute(r)
}

/*
GetWorkflowSchemeDraft Get draft workflow scheme

Returns the draft workflow scheme for an active workflow scheme. Draft workflow schemes allow changes to be made to the active workflow schemes: When an active workflow scheme is updated, a draft copy is created. The draft is modified, then the changes in the draft are copied back to the active workflow scheme. See [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg) for more information.  
Note that:

 *  Only active workflow schemes can have draft workflow schemes.
 *  An active workflow scheme can only have one draft workflow scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the active workflow scheme that the draft was created from.
 @return ApiGetWorkflowSchemeDraftRequest
*/
func (a *WorkflowSchemeDraftsAPIService) GetWorkflowSchemeDraft(ctx context.Context, id int64) ApiGetWorkflowSchemeDraftRequest {
	return ApiGetWorkflowSchemeDraftRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) GetWorkflowSchemeDraftExecute(r ApiGetWorkflowSchemeDraftRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.GetWorkflowSchemeDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkflowSchemeDraftIssueTypeRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	issueType string
}

func (r ApiGetWorkflowSchemeDraftIssueTypeRequest) Execute() (*IssueTypeWorkflowMapping, *http.Response, error) {
	return r.ApiService.GetWorkflowSchemeDraftIssueTypeExecute(r)
}

/*
GetWorkflowSchemeDraftIssueType Get workflow for issue type in draft workflow scheme

Returns the issue type-workflow mapping for an issue type in a workflow scheme's draft.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @param issueType The ID of the issue type.
 @return ApiGetWorkflowSchemeDraftIssueTypeRequest
*/
func (a *WorkflowSchemeDraftsAPIService) GetWorkflowSchemeDraftIssueType(ctx context.Context, id int64, issueType string) ApiGetWorkflowSchemeDraftIssueTypeRequest {
	return ApiGetWorkflowSchemeDraftIssueTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		issueType: issueType,
	}
}

// Execute executes the request
//  @return IssueTypeWorkflowMapping
func (a *WorkflowSchemeDraftsAPIService) GetWorkflowSchemeDraftIssueTypeExecute(r ApiGetWorkflowSchemeDraftIssueTypeRequest) (*IssueTypeWorkflowMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IssueTypeWorkflowMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.GetWorkflowSchemeDraftIssueType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issueType"+"}", url.PathEscape(parameterValueToString(r.issueType, "issueType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishDraftWorkflowSchemeRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	publishDraftWorkflowScheme *PublishDraftWorkflowScheme
	validateOnly *bool
}

// Details of the status mappings.
func (r ApiPublishDraftWorkflowSchemeRequest) PublishDraftWorkflowScheme(publishDraftWorkflowScheme PublishDraftWorkflowScheme) ApiPublishDraftWorkflowSchemeRequest {
	r.publishDraftWorkflowScheme = &publishDraftWorkflowScheme
	return r
}

// Whether the request only performs a validation.
func (r ApiPublishDraftWorkflowSchemeRequest) ValidateOnly(validateOnly bool) ApiPublishDraftWorkflowSchemeRequest {
	r.validateOnly = &validateOnly
	return r
}

func (r ApiPublishDraftWorkflowSchemeRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublishDraftWorkflowSchemeExecute(r)
}

/*
PublishDraftWorkflowScheme Publish draft workflow scheme

Publishes a draft workflow scheme.

Where the draft workflow includes new workflow statuses for an issue type, mappings are provided to update issues with the original workflow status to the new workflow status.

This operation is [asynchronous](#async). Follow the `location` link in the response to determine the status of the task and use [Get task](#api-rest-api-3-task-taskId-get) to obtain updates.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiPublishDraftWorkflowSchemeRequest
*/
func (a *WorkflowSchemeDraftsAPIService) PublishDraftWorkflowScheme(ctx context.Context, id int64) ApiPublishDraftWorkflowSchemeRequest {
	return ApiPublishDraftWorkflowSchemeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *WorkflowSchemeDraftsAPIService) PublishDraftWorkflowSchemeExecute(r ApiPublishDraftWorkflowSchemeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.PublishDraftWorkflowScheme")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publishDraftWorkflowScheme == nil {
		return nil, reportError("publishDraftWorkflowScheme is required and must be specified")
	}

	if r.validateOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateOnly", r.validateOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateOnly", defaultValue, "form", "")
		r.validateOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publishDraftWorkflowScheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 303 {
			var v TaskProgressBeanObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetWorkflowSchemeDraftIssueTypeRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	issueType string
	issueTypeWorkflowMapping *IssueTypeWorkflowMapping
}

// The issue type-project mapping.
func (r ApiSetWorkflowSchemeDraftIssueTypeRequest) IssueTypeWorkflowMapping(issueTypeWorkflowMapping IssueTypeWorkflowMapping) ApiSetWorkflowSchemeDraftIssueTypeRequest {
	r.issueTypeWorkflowMapping = &issueTypeWorkflowMapping
	return r
}

func (r ApiSetWorkflowSchemeDraftIssueTypeRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.SetWorkflowSchemeDraftIssueTypeExecute(r)
}

/*
SetWorkflowSchemeDraftIssueType Set workflow for issue type in draft workflow scheme

Sets the workflow for an issue type in a workflow scheme's draft.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @param issueType The ID of the issue type.
 @return ApiSetWorkflowSchemeDraftIssueTypeRequest
*/
func (a *WorkflowSchemeDraftsAPIService) SetWorkflowSchemeDraftIssueType(ctx context.Context, id int64, issueType string) ApiSetWorkflowSchemeDraftIssueTypeRequest {
	return ApiSetWorkflowSchemeDraftIssueTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		issueType: issueType,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) SetWorkflowSchemeDraftIssueTypeExecute(r ApiSetWorkflowSchemeDraftIssueTypeRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.SetWorkflowSchemeDraftIssueType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issueType"+"}", url.PathEscape(parameterValueToString(r.issueType, "issueType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeWorkflowMapping == nil {
		return localVarReturnValue, nil, reportError("issueTypeWorkflowMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeWorkflowMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDraftDefaultWorkflowRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	defaultWorkflow *DefaultWorkflow
}

// The object for the new default workflow.
func (r ApiUpdateDraftDefaultWorkflowRequest) DefaultWorkflow(defaultWorkflow DefaultWorkflow) ApiUpdateDraftDefaultWorkflowRequest {
	r.defaultWorkflow = &defaultWorkflow
	return r
}

func (r ApiUpdateDraftDefaultWorkflowRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.UpdateDraftDefaultWorkflowExecute(r)
}

/*
UpdateDraftDefaultWorkflow Update draft default workflow

Sets the default workflow for a workflow scheme's draft.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiUpdateDraftDefaultWorkflowRequest
*/
func (a *WorkflowSchemeDraftsAPIService) UpdateDraftDefaultWorkflow(ctx context.Context, id int64) ApiUpdateDraftDefaultWorkflowRequest {
	return ApiUpdateDraftDefaultWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) UpdateDraftDefaultWorkflowExecute(r ApiUpdateDraftDefaultWorkflowRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.UpdateDraftDefaultWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/default"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.defaultWorkflow == nil {
		return localVarReturnValue, nil, reportError("defaultWorkflow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.defaultWorkflow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDraftWorkflowMappingRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	workflowName *string
	issueTypesWorkflowMapping *IssueTypesWorkflowMapping
}

// The name of the workflow.
func (r ApiUpdateDraftWorkflowMappingRequest) WorkflowName(workflowName string) ApiUpdateDraftWorkflowMappingRequest {
	r.workflowName = &workflowName
	return r
}

func (r ApiUpdateDraftWorkflowMappingRequest) IssueTypesWorkflowMapping(issueTypesWorkflowMapping IssueTypesWorkflowMapping) ApiUpdateDraftWorkflowMappingRequest {
	r.issueTypesWorkflowMapping = &issueTypesWorkflowMapping
	return r
}

func (r ApiUpdateDraftWorkflowMappingRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.UpdateDraftWorkflowMappingExecute(r)
}

/*
UpdateDraftWorkflowMapping Set issue types for workflow in workflow scheme

Sets the issue types for a workflow in a workflow scheme's draft. The workflow can also be set as the default workflow for the draft workflow scheme. Unmapped issues types are mapped to the default workflow.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the workflow scheme that the draft belongs to.
 @return ApiUpdateDraftWorkflowMappingRequest
*/
func (a *WorkflowSchemeDraftsAPIService) UpdateDraftWorkflowMapping(ctx context.Context, id int64) ApiUpdateDraftWorkflowMappingRequest {
	return ApiUpdateDraftWorkflowMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) UpdateDraftWorkflowMappingExecute(r ApiUpdateDraftWorkflowMappingRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.UpdateDraftWorkflowMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workflowName == nil {
		return localVarReturnValue, nil, reportError("workflowName is required and must be specified")
	}
	if r.issueTypesWorkflowMapping == nil {
		return localVarReturnValue, nil, reportError("issueTypesWorkflowMapping is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "workflowName", r.workflowName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypesWorkflowMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWorkflowSchemeDraftRequest struct {
	ctx context.Context
	ApiService *WorkflowSchemeDraftsAPIService
	id int64
	workflowScheme *WorkflowScheme
}

func (r ApiUpdateWorkflowSchemeDraftRequest) WorkflowScheme(workflowScheme WorkflowScheme) ApiUpdateWorkflowSchemeDraftRequest {
	r.workflowScheme = &workflowScheme
	return r
}

func (r ApiUpdateWorkflowSchemeDraftRequest) Execute() (*WorkflowScheme, *http.Response, error) {
	return r.ApiService.UpdateWorkflowSchemeDraftExecute(r)
}

/*
UpdateWorkflowSchemeDraft Update draft workflow scheme

Updates a draft workflow scheme. If a draft workflow scheme does not exist for the active workflow scheme, then a draft is created. Note that an active workflow scheme can only have one draft workflow scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the active workflow scheme that the draft was created from.
 @return ApiUpdateWorkflowSchemeDraftRequest
*/
func (a *WorkflowSchemeDraftsAPIService) UpdateWorkflowSchemeDraft(ctx context.Context, id int64) ApiUpdateWorkflowSchemeDraftRequest {
	return ApiUpdateWorkflowSchemeDraftRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WorkflowScheme
func (a *WorkflowSchemeDraftsAPIService) UpdateWorkflowSchemeDraftExecute(r ApiUpdateWorkflowSchemeDraftRequest) (*WorkflowScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowSchemeDraftsAPIService.UpdateWorkflowSchemeDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/workflowscheme/{id}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workflowScheme == nil {
		return localVarReturnValue, nil, reportError("workflowScheme is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowScheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
