/*
The Jira Cloud platform REST API

Jira Cloud platform REST API documentation

API version: 1001.0.0-SNAPSHOT-e4f05783a723054bc221d0780e48a2dc2ed25997
Contact: ecosystem@atlassian.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IssueTypeSchemesAPIService IssueTypeSchemesAPI service
type IssueTypeSchemesAPIService service

type ApiAddIssueTypesToIssueTypeSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeId int64
	issueTypeIds *IssueTypeIds
}

func (r ApiAddIssueTypesToIssueTypeSchemeRequest) IssueTypeIds(issueTypeIds IssueTypeIds) ApiAddIssueTypesToIssueTypeSchemeRequest {
	r.issueTypeIds = &issueTypeIds
	return r
}

func (r ApiAddIssueTypesToIssueTypeSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AddIssueTypesToIssueTypeSchemeExecute(r)
}

/*
AddIssueTypesToIssueTypeScheme Add issue types to issue type scheme

Adds issue types to an issue type scheme.

The added issue types are appended to the issue types list.

If any of the issue types exist in the issue type scheme, the operation fails and no issue types are added.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeSchemeId The ID of the issue type scheme.
 @return ApiAddIssueTypesToIssueTypeSchemeRequest
*/
func (a *IssueTypeSchemesAPIService) AddIssueTypesToIssueTypeScheme(ctx context.Context, issueTypeSchemeId int64) ApiAddIssueTypesToIssueTypeSchemeRequest {
	return ApiAddIssueTypesToIssueTypeSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeSchemeId: issueTypeSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeSchemesAPIService) AddIssueTypesToIssueTypeSchemeExecute(r ApiAddIssueTypesToIssueTypeSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.AddIssueTypesToIssueTypeScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeSchemeId, "issueTypeSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeIds == nil {
		return localVarReturnValue, nil, reportError("issueTypeIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeIds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignIssueTypeSchemeToProjectRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeProjectAssociation *IssueTypeSchemeProjectAssociation
}

func (r ApiAssignIssueTypeSchemeToProjectRequest) IssueTypeSchemeProjectAssociation(issueTypeSchemeProjectAssociation IssueTypeSchemeProjectAssociation) ApiAssignIssueTypeSchemeToProjectRequest {
	r.issueTypeSchemeProjectAssociation = &issueTypeSchemeProjectAssociation
	return r
}

func (r ApiAssignIssueTypeSchemeToProjectRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AssignIssueTypeSchemeToProjectExecute(r)
}

/*
AssignIssueTypeSchemeToProject Assign issue type scheme to project

Assigns an issue type scheme to a project.

If any issues in the project are assigned issue types not present in the new scheme, the operation will fail. To complete the assignment those issues must be updated to use issue types in the new scheme.

Issue type schemes can only be assigned to classic projects.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssignIssueTypeSchemeToProjectRequest
*/
func (a *IssueTypeSchemesAPIService) AssignIssueTypeSchemeToProject(ctx context.Context) ApiAssignIssueTypeSchemeToProjectRequest {
	return ApiAssignIssueTypeSchemeToProjectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeSchemesAPIService) AssignIssueTypeSchemeToProjectExecute(r ApiAssignIssueTypeSchemeToProjectRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.AssignIssueTypeSchemeToProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeSchemeProjectAssociation == nil {
		return localVarReturnValue, nil, reportError("issueTypeSchemeProjectAssociation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeSchemeProjectAssociation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIssueTypeSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeDetails *IssueTypeSchemeDetails
}

func (r ApiCreateIssueTypeSchemeRequest) IssueTypeSchemeDetails(issueTypeSchemeDetails IssueTypeSchemeDetails) ApiCreateIssueTypeSchemeRequest {
	r.issueTypeSchemeDetails = &issueTypeSchemeDetails
	return r
}

func (r ApiCreateIssueTypeSchemeRequest) Execute() (*IssueTypeSchemeID, *http.Response, error) {
	return r.ApiService.CreateIssueTypeSchemeExecute(r)
}

/*
CreateIssueTypeScheme Create issue type scheme

Creates an issue type scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIssueTypeSchemeRequest
*/
func (a *IssueTypeSchemesAPIService) CreateIssueTypeScheme(ctx context.Context) ApiCreateIssueTypeSchemeRequest {
	return ApiCreateIssueTypeSchemeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IssueTypeSchemeID
func (a *IssueTypeSchemesAPIService) CreateIssueTypeSchemeExecute(r ApiCreateIssueTypeSchemeRequest) (*IssueTypeSchemeID, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IssueTypeSchemeID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.CreateIssueTypeScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeSchemeDetails == nil {
		return localVarReturnValue, nil, reportError("issueTypeSchemeDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeSchemeDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIssueTypeSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeId int64
}

func (r ApiDeleteIssueTypeSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteIssueTypeSchemeExecute(r)
}

/*
DeleteIssueTypeScheme Delete issue type scheme

Deletes an issue type scheme.

Only issue type schemes used in classic projects can be deleted.

Any projects assigned to the scheme are reassigned to the default issue type scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeSchemeId The ID of the issue type scheme.
 @return ApiDeleteIssueTypeSchemeRequest
*/
func (a *IssueTypeSchemesAPIService) DeleteIssueTypeScheme(ctx context.Context, issueTypeSchemeId int64) ApiDeleteIssueTypeSchemeRequest {
	return ApiDeleteIssueTypeSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeSchemeId: issueTypeSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeSchemesAPIService) DeleteIssueTypeSchemeExecute(r ApiDeleteIssueTypeSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.DeleteIssueTypeScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeSchemeId, "issueTypeSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllIssueTypeSchemesRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	startAt *int64
	maxResults *int32
	id *[]int64
	orderBy *string
	expand *string
	queryString *string
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetAllIssueTypeSchemesRequest) StartAt(startAt int64) ApiGetAllIssueTypeSchemesRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetAllIssueTypeSchemesRequest) MaxResults(maxResults int32) ApiGetAllIssueTypeSchemesRequest {
	r.maxResults = &maxResults
	return r
}

// The list of issue type schemes IDs. To include multiple IDs, provide an ampersand-separated list. For example, &#x60;id&#x3D;10000&amp;id&#x3D;10001&#x60;.
func (r ApiGetAllIssueTypeSchemesRequest) Id(id []int64) ApiGetAllIssueTypeSchemesRequest {
	r.id = &id
	return r
}

// [Order](#ordering) the results by a field:   *  &#x60;name&#x60; Sorts by issue type scheme name.  *  &#x60;id&#x60; Sorts by issue type scheme ID.
func (r ApiGetAllIssueTypeSchemesRequest) OrderBy(orderBy string) ApiGetAllIssueTypeSchemesRequest {
	r.orderBy = &orderBy
	return r
}

// Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;projects&#x60; For each issue type schemes, returns information about the projects the issue type scheme is assigned to.  *  &#x60;issueTypes&#x60; For each issue type schemes, returns information about the issueTypes the issue type scheme have.
func (r ApiGetAllIssueTypeSchemesRequest) Expand(expand string) ApiGetAllIssueTypeSchemesRequest {
	r.expand = &expand
	return r
}

// String used to perform a case-insensitive partial match with issue type scheme name.
func (r ApiGetAllIssueTypeSchemesRequest) QueryString(queryString string) ApiGetAllIssueTypeSchemesRequest {
	r.queryString = &queryString
	return r
}

func (r ApiGetAllIssueTypeSchemesRequest) Execute() (*PageBeanIssueTypeScheme, *http.Response, error) {
	return r.ApiService.GetAllIssueTypeSchemesExecute(r)
}

/*
GetAllIssueTypeSchemes Get all issue type schemes

Returns a [paginated](#pagination) list of issue type schemes.

Only issue type schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllIssueTypeSchemesRequest
*/
func (a *IssueTypeSchemesAPIService) GetAllIssueTypeSchemes(ctx context.Context) ApiGetAllIssueTypeSchemesRequest {
	return ApiGetAllIssueTypeSchemesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanIssueTypeScheme
func (a *IssueTypeSchemesAPIService) GetAllIssueTypeSchemesExecute(r ApiGetAllIssueTypeSchemesRequest) (*PageBeanIssueTypeScheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanIssueTypeScheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.GetAllIssueTypeSchemes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", defaultValue, "form", "")
		r.orderBy = &defaultValue
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", defaultValue, "form", "")
		r.expand = &defaultValue
	}
	if r.queryString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryString", r.queryString, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryString", defaultValue, "form", "")
		r.queryString = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueTypeSchemeForProjectsRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	projectId *[]int64
	startAt *int64
	maxResults *int32
}

// The list of project IDs. To include multiple project IDs, provide an ampersand-separated list. For example, &#x60;projectId&#x3D;10000&amp;projectId&#x3D;10001&#x60;.
func (r ApiGetIssueTypeSchemeForProjectsRequest) ProjectId(projectId []int64) ApiGetIssueTypeSchemeForProjectsRequest {
	r.projectId = &projectId
	return r
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetIssueTypeSchemeForProjectsRequest) StartAt(startAt int64) ApiGetIssueTypeSchemeForProjectsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetIssueTypeSchemeForProjectsRequest) MaxResults(maxResults int32) ApiGetIssueTypeSchemeForProjectsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetIssueTypeSchemeForProjectsRequest) Execute() (*PageBeanIssueTypeSchemeProjects, *http.Response, error) {
	return r.ApiService.GetIssueTypeSchemeForProjectsExecute(r)
}

/*
GetIssueTypeSchemeForProjects Get issue type schemes for projects

Returns a [paginated](#pagination) list of issue type schemes and, for each issue type scheme, a list of the projects that use it.

Only issue type schemes used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueTypeSchemeForProjectsRequest
*/
func (a *IssueTypeSchemesAPIService) GetIssueTypeSchemeForProjects(ctx context.Context) ApiGetIssueTypeSchemeForProjectsRequest {
	return ApiGetIssueTypeSchemeForProjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanIssueTypeSchemeProjects
func (a *IssueTypeSchemesAPIService) GetIssueTypeSchemeForProjectsExecute(r ApiGetIssueTypeSchemeForProjectsRequest) (*PageBeanIssueTypeSchemeProjects, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanIssueTypeSchemeProjects
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.GetIssueTypeSchemeForProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	{
		t := *r.projectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueTypeSchemesMappingRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	startAt *int64
	maxResults *int32
	issueTypeSchemeId *[]int64
}

// The index of the first item to return in a page of results (page offset).
func (r ApiGetIssueTypeSchemesMappingRequest) StartAt(startAt int64) ApiGetIssueTypeSchemesMappingRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of items to return per page.
func (r ApiGetIssueTypeSchemesMappingRequest) MaxResults(maxResults int32) ApiGetIssueTypeSchemesMappingRequest {
	r.maxResults = &maxResults
	return r
}

// The list of issue type scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, &#x60;issueTypeSchemeId&#x3D;10000&amp;issueTypeSchemeId&#x3D;10001&#x60;.
func (r ApiGetIssueTypeSchemesMappingRequest) IssueTypeSchemeId(issueTypeSchemeId []int64) ApiGetIssueTypeSchemesMappingRequest {
	r.issueTypeSchemeId = &issueTypeSchemeId
	return r
}

func (r ApiGetIssueTypeSchemesMappingRequest) Execute() (*PageBeanIssueTypeSchemeMapping, *http.Response, error) {
	return r.ApiService.GetIssueTypeSchemesMappingExecute(r)
}

/*
GetIssueTypeSchemesMapping Get issue type scheme items

Returns a [paginated](#pagination) list of issue type scheme items.

Only issue type scheme items used in classic projects are returned.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueTypeSchemesMappingRequest
*/
func (a *IssueTypeSchemesAPIService) GetIssueTypeSchemesMapping(ctx context.Context) ApiGetIssueTypeSchemesMappingRequest {
	return ApiGetIssueTypeSchemesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageBeanIssueTypeSchemeMapping
func (a *IssueTypeSchemesAPIService) GetIssueTypeSchemesMappingExecute(r ApiGetIssueTypeSchemesMappingRequest) (*PageBeanIssueTypeSchemeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageBeanIssueTypeSchemeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.GetIssueTypeSchemesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.issueTypeSchemeId != nil {
		t := *r.issueTypeSchemeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "issueTypeSchemeId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "issueTypeSchemeId", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveIssueTypeFromIssueTypeSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeId int64
	issueTypeId int64
}

func (r ApiRemoveIssueTypeFromIssueTypeSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.RemoveIssueTypeFromIssueTypeSchemeExecute(r)
}

/*
RemoveIssueTypeFromIssueTypeScheme Remove issue type from issue type scheme

Removes an issue type from an issue type scheme.

This operation cannot remove:

 *  any issue type used by issues.
 *  any issue types from the default issue type scheme.
 *  the last standard issue type from an issue type scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeSchemeId The ID of the issue type scheme.
 @param issueTypeId The ID of the issue type.
 @return ApiRemoveIssueTypeFromIssueTypeSchemeRequest
*/
func (a *IssueTypeSchemesAPIService) RemoveIssueTypeFromIssueTypeScheme(ctx context.Context, issueTypeSchemeId int64, issueTypeId int64) ApiRemoveIssueTypeFromIssueTypeSchemeRequest {
	return ApiRemoveIssueTypeFromIssueTypeSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeSchemeId: issueTypeSchemeId,
		issueTypeId: issueTypeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeSchemesAPIService) RemoveIssueTypeFromIssueTypeSchemeExecute(r ApiRemoveIssueTypeFromIssueTypeSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.RemoveIssueTypeFromIssueTypeScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/{issueTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeSchemeId, "issueTypeSchemeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeId, "issueTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReorderIssueTypesInIssueTypeSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeId int64
	orderOfIssueTypes *OrderOfIssueTypes
}

func (r ApiReorderIssueTypesInIssueTypeSchemeRequest) OrderOfIssueTypes(orderOfIssueTypes OrderOfIssueTypes) ApiReorderIssueTypesInIssueTypeSchemeRequest {
	r.orderOfIssueTypes = &orderOfIssueTypes
	return r
}

func (r ApiReorderIssueTypesInIssueTypeSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ReorderIssueTypesInIssueTypeSchemeExecute(r)
}

/*
ReorderIssueTypesInIssueTypeScheme Change order of issue types

Changes the order of issue types in an issue type scheme.

The request body parameters must meet the following requirements:

 *  all of the issue types must belong to the issue type scheme.
 *  either `after` or `position` must be provided.
 *  the issue type in `after` must not be in the issue type list.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeSchemeId The ID of the issue type scheme.
 @return ApiReorderIssueTypesInIssueTypeSchemeRequest
*/
func (a *IssueTypeSchemesAPIService) ReorderIssueTypesInIssueTypeScheme(ctx context.Context, issueTypeSchemeId int64) ApiReorderIssueTypesInIssueTypeSchemeRequest {
	return ApiReorderIssueTypesInIssueTypeSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeSchemeId: issueTypeSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeSchemesAPIService) ReorderIssueTypesInIssueTypeSchemeExecute(r ApiReorderIssueTypesInIssueTypeSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.ReorderIssueTypesInIssueTypeScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/move"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeSchemeId, "issueTypeSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderOfIssueTypes == nil {
		return localVarReturnValue, nil, reportError("orderOfIssueTypes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderOfIssueTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIssueTypeSchemeRequest struct {
	ctx context.Context
	ApiService *IssueTypeSchemesAPIService
	issueTypeSchemeId int64
	issueTypeSchemeUpdateDetails *IssueTypeSchemeUpdateDetails
}

func (r ApiUpdateIssueTypeSchemeRequest) IssueTypeSchemeUpdateDetails(issueTypeSchemeUpdateDetails IssueTypeSchemeUpdateDetails) ApiUpdateIssueTypeSchemeRequest {
	r.issueTypeSchemeUpdateDetails = &issueTypeSchemeUpdateDetails
	return r
}

func (r ApiUpdateIssueTypeSchemeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateIssueTypeSchemeExecute(r)
}

/*
UpdateIssueTypeScheme Update issue type scheme

Updates an issue type scheme.

**[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueTypeSchemeId The ID of the issue type scheme.
 @return ApiUpdateIssueTypeSchemeRequest
*/
func (a *IssueTypeSchemesAPIService) UpdateIssueTypeScheme(ctx context.Context, issueTypeSchemeId int64) ApiUpdateIssueTypeSchemeRequest {
	return ApiUpdateIssueTypeSchemeRequest{
		ApiService: a,
		ctx: ctx,
		issueTypeSchemeId: issueTypeSchemeId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *IssueTypeSchemesAPIService) UpdateIssueTypeSchemeExecute(r ApiUpdateIssueTypeSchemeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTypeSchemesAPIService.UpdateIssueTypeScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueTypeSchemeId"+"}", url.PathEscape(parameterValueToString(r.issueTypeSchemeId, "issueTypeSchemeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.issueTypeSchemeUpdateDetails == nil {
		return localVarReturnValue, nil, reportError("issueTypeSchemeUpdateDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.issueTypeSchemeUpdateDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
