/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FeatureFlagsAPIService FeatureFlagsAPI service
type FeatureFlagsAPIService service

type ApiDeleteFeatureFlagByIdRequest struct {
	ctx context.Context
	ApiService *FeatureFlagsAPIService
	authorization *string
	featureFlagId string
	updateSequenceId *int64
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Feature Flags module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiDeleteFeatureFlagByIdRequest) Authorization(authorization string) ApiDeleteFeatureFlagByIdRequest {
	r.authorization = &authorization
	return r
}

// This parameter usage is no longer supported.  An optional &#x60;_updateSequenceId&#x60; to use to control deletion.  Only stored data with an &#x60;updateSequenceId&#x60; less than or equal to that provided will be deleted. This can be used help ensure submit/delete requests are applied correctly if issued close together. 
// Deprecated
func (r ApiDeleteFeatureFlagByIdRequest) UpdateSequenceId(updateSequenceId int64) ApiDeleteFeatureFlagByIdRequest {
	r.updateSequenceId = &updateSequenceId
	return r
}

func (r ApiDeleteFeatureFlagByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFeatureFlagByIdExecute(r)
}

/*
DeleteFeatureFlagById Delete a Feature Flag by ID

Delete the Feature Flag data currently stored for the given ID.

Deletion is performed asynchronously. The getFeatureFlagById operation can be used to confirm that data has been deleted successfully (if needed).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param featureFlagId The ID of the Feature Flag to delete. 
 @return ApiDeleteFeatureFlagByIdRequest
*/
func (a *FeatureFlagsAPIService) DeleteFeatureFlagById(ctx context.Context, featureFlagId string) ApiDeleteFeatureFlagByIdRequest {
	return ApiDeleteFeatureFlagByIdRequest{
		ApiService: a,
		ctx: ctx,
		featureFlagId: featureFlagId,
	}
}

// Execute executes the request
func (a *FeatureFlagsAPIService) DeleteFeatureFlagByIdExecute(r ApiDeleteFeatureFlagByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.DeleteFeatureFlagById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/featureflags/0.1/flag/{featureFlagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagId"+"}", url.PathEscape(parameterValueToString(r.featureFlagId, "featureFlagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.featureFlagId) > 255 {
		return nil, reportError("featureFlagId must have less than 255 elements")
	}

	if r.updateSequenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_updateSequenceId", r.updateSequenceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFeatureFlagsByPropertyRequest struct {
	ctx context.Context
	ApiService *FeatureFlagsAPIService
	authorization *string
	updateSequenceId *int64
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Feature Flags module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiDeleteFeatureFlagsByPropertyRequest) Authorization(authorization string) ApiDeleteFeatureFlagsByPropertyRequest {
	r.authorization = &authorization
	return r
}

// This parameter usage is no longer supported.  An optional &#x60;_updateSequenceId&#x60; to use to control deletion.  Only stored data with an &#x60;updateSequenceId&#x60; less than or equal to that provided will be deleted. This can be used help ensure submit/delete requests are applied correctly if issued close together.  If not provided, all stored data that matches the request will be deleted. 
// Deprecated
func (r ApiDeleteFeatureFlagsByPropertyRequest) UpdateSequenceId(updateSequenceId int64) ApiDeleteFeatureFlagsByPropertyRequest {
	r.updateSequenceId = &updateSequenceId
	return r
}

func (r ApiDeleteFeatureFlagsByPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFeatureFlagsByPropertyExecute(r)
}

/*
DeleteFeatureFlagsByProperty Delete Feature Flags by Property

Bulk delete all Feature Flags that match the given request.

One or more query params must be supplied to specify Properties to delete by. Optional param `_updateSequenceId` is no longer supported.
If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND).
See the documentation for the submitFeatureFlags operation for more details.

e.g. DELETE /bulkByProperties?accountId=account-123&createdBy=user-456

Deletion is performed asynchronously. The getFeatureFlagById operation can be used to confirm that data has been deleted successfully (if needed).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFeatureFlagsByPropertyRequest
*/
func (a *FeatureFlagsAPIService) DeleteFeatureFlagsByProperty(ctx context.Context) ApiDeleteFeatureFlagsByPropertyRequest {
	return ApiDeleteFeatureFlagsByPropertyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FeatureFlagsAPIService) DeleteFeatureFlagsByPropertyExecute(r ApiDeleteFeatureFlagsByPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.DeleteFeatureFlagsByProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/featureflags/0.1/bulkByProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.updateSequenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_updateSequenceId", r.updateSequenceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFeatureFlagByIdRequest struct {
	ctx context.Context
	ApiService *FeatureFlagsAPIService
	authorization *string
	featureFlagId string
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Feature Flags module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiGetFeatureFlagByIdRequest) Authorization(authorization string) ApiGetFeatureFlagByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetFeatureFlagByIdRequest) Execute() (*FeatureFlagData, *http.Response, error) {
	return r.ApiService.GetFeatureFlagByIdExecute(r)
}

/*
GetFeatureFlagById Get a Feature Flag by ID

Retrieve the currently stored Feature Flag data for the given ID.

The result will be what is currently stored, ignoring any pending updates or deletes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param featureFlagId The ID of the Feature Flag to fetch. 
 @return ApiGetFeatureFlagByIdRequest
*/
func (a *FeatureFlagsAPIService) GetFeatureFlagById(ctx context.Context, featureFlagId string) ApiGetFeatureFlagByIdRequest {
	return ApiGetFeatureFlagByIdRequest{
		ApiService: a,
		ctx: ctx,
		featureFlagId: featureFlagId,
	}
}

// Execute executes the request
//  @return FeatureFlagData
func (a *FeatureFlagsAPIService) GetFeatureFlagByIdExecute(r ApiGetFeatureFlagByIdRequest) (*FeatureFlagData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureFlagData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.GetFeatureFlagById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/featureflags/0.1/flag/{featureFlagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagId"+"}", url.PathEscape(parameterValueToString(r.featureFlagId, "featureFlagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.featureFlagId) > 255 {
		return localVarReturnValue, nil, reportError("featureFlagId must have less than 255 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitFeatureFlagsRequest struct {
	ctx context.Context
	ApiService *FeatureFlagsAPIService
	authorization *string
	submitFeatureFlagRequest *SubmitFeatureFlagRequest
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Feature Flags module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiSubmitFeatureFlagsRequest) Authorization(authorization string) ApiSubmitFeatureFlagsRequest {
	r.authorization = &authorization
	return r
}

// Feature Flag data to submit. 
func (r ApiSubmitFeatureFlagsRequest) SubmitFeatureFlagRequest(submitFeatureFlagRequest SubmitFeatureFlagRequest) ApiSubmitFeatureFlagsRequest {
	r.submitFeatureFlagRequest = &submitFeatureFlagRequest
	return r
}

func (r ApiSubmitFeatureFlagsRequest) Execute() (*SubmitFeatureFlagsResponse, *http.Response, error) {
	return r.ApiService.SubmitFeatureFlagsExecute(r)
}

/*
SubmitFeatureFlags Submit Feature Flag data

Update / insert Feature Flag data.

Feature Flags are identified by their ID, and existing Feature Flag data for the same ID will be replaced if it exists and the updateSequenceId of existing data is less than the incoming data.

Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are available within a short period of time, but may take some time during peak load and/or maintenance times. The getFeatureFlagById operation can be used to confirm that data has been stored successfully (if needed).

In the case of multiple Feature Flags being submitted in one request, each is validated individually prior to submission. Details of which Feature Flags failed submission (if any) are available in the response object.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitFeatureFlagsRequest
*/
func (a *FeatureFlagsAPIService) SubmitFeatureFlags(ctx context.Context) ApiSubmitFeatureFlagsRequest {
	return ApiSubmitFeatureFlagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitFeatureFlagsResponse
func (a *FeatureFlagsAPIService) SubmitFeatureFlagsExecute(r ApiSubmitFeatureFlagsRequest) (*SubmitFeatureFlagsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitFeatureFlagsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.SubmitFeatureFlags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/featureflags/0.1/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.submitFeatureFlagRequest == nil {
		return localVarReturnValue, nil, reportError("submitFeatureFlagRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.submitFeatureFlagRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
