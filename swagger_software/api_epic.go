/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// EpicAPIService EpicAPI service
type EpicAPIService service

type ApiGetEpicRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	epicIdOrKey string
}

func (r ApiGetEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEpicExecute(r)
}

/*
GetEpic Get epic

Returns the epic for a given epic ID. This epic will only be returned if the user has permission to view it. **Note:** This operation does not work for epics in next-gen projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param epicIdOrKey The id or key of the requested epic.
 @return ApiGetEpicRequest
*/
func (a *EpicAPIService) GetEpic(ctx context.Context, epicIdOrKey string) ApiGetEpicRequest {
	return ApiGetEpicRequest{
		ApiService: a,
		ctx: ctx,
		epicIdOrKey: epicIdOrKey,
	}
}

// Execute executes the request
func (a *EpicAPIService) GetEpicExecute(r ApiGetEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.GetEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/{epicIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"epicIdOrKey"+"}", url.PathEscape(parameterValueToString(r.epicIdOrKey, "epicIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIssuesForEpicRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	epicIdOrKey string
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetIssuesForEpicRequest) StartAt(startAt int64) ApiGetIssuesForEpicRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. Default: 50. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetIssuesForEpicRequest) MaxResults(maxResults int32) ApiGetIssuesForEpicRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.   Note that &#x60;username&#x60; and &#x60;userkey&#x60; can&#39;t be used as search terms for this parameter due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetIssuesForEpicRequest) Jql(jql string) ApiGetIssuesForEpicRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetIssuesForEpicRequest) ValidateQuery(validateQuery bool) ApiGetIssuesForEpicRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssuesForEpicRequest) Fields(fields []map[string]interface{}) ApiGetIssuesForEpicRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetIssuesForEpicRequest) Expand(expand string) ApiGetIssuesForEpicRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssuesForEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetIssuesForEpicExecute(r)
}

/*
GetIssuesForEpic Get issues for epic

Returns all issues that belong to the epic, for the given epic ID. This only includes issues that the user has permission to view. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic. By default, the returned issues are ordered by rank. **Note:** If you are querying a next-gen project, do not use this operation. Instead, search for issues that belong to an epic by using the [Search for issues using JQL](https://developer.atlassian.com/cloud/jira/platform/rest/v2/#api-rest-api-2-search-get) operation in the Jira platform REST API. Build your JQL query using the `parent` clause. For more information on the `parent` JQL field, see [Advanced searching](https://confluence.atlassian.com/x/dAiiLQ#Advancedsearching-fieldsreference-Parent).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param epicIdOrKey The id or key of the epic that contains the requested issues.
 @return ApiGetIssuesForEpicRequest
*/
func (a *EpicAPIService) GetIssuesForEpic(ctx context.Context, epicIdOrKey string) ApiGetIssuesForEpicRequest {
	return ApiGetIssuesForEpicRequest{
		ApiService: a,
		ctx: ctx,
		epicIdOrKey: epicIdOrKey,
	}
}

// Execute executes the request
func (a *EpicAPIService) GetIssuesForEpicExecute(r ApiGetIssuesForEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.GetIssuesForEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/{epicIdOrKey}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"epicIdOrKey"+"}", url.PathEscape(parameterValueToString(r.epicIdOrKey, "epicIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIssuesWithoutEpicRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetIssuesWithoutEpicRequest) StartAt(startAt int64) ApiGetIssuesWithoutEpicRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetIssuesWithoutEpicRequest) MaxResults(maxResults int32) ApiGetIssuesWithoutEpicRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.
func (r ApiGetIssuesWithoutEpicRequest) Jql(jql string) ApiGetIssuesWithoutEpicRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetIssuesWithoutEpicRequest) ValidateQuery(validateQuery bool) ApiGetIssuesWithoutEpicRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssuesWithoutEpicRequest) Fields(fields []map[string]interface{}) ApiGetIssuesWithoutEpicRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetIssuesWithoutEpicRequest) Expand(expand string) ApiGetIssuesWithoutEpicRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssuesWithoutEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetIssuesWithoutEpicExecute(r)
}

/*
GetIssuesWithoutEpic Get issues without epic

Returns all issues that do not belong to any epic. This only includes issues that the user has permission to view. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic. By default, the returned issues are ordered by rank. **Note:** If you are querying a next-gen project, do not use this operation. Instead, search for issues that don't belong to an epic by using the [Search for issues using JQL](https://developer.atlassian.com/cloud/jira/platform/rest/v2/#api-rest-api-2-search-get) operation in the Jira platform REST API. Build your JQL query using the `parent is empty` clause. For more information on the `parent` JQL field, see [Advanced searching](https://confluence.atlassian.com/x/dAiiLQ#Advancedsearching-fieldsreference-Parent).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuesWithoutEpicRequest
*/
func (a *EpicAPIService) GetIssuesWithoutEpic(ctx context.Context) ApiGetIssuesWithoutEpicRequest {
	return ApiGetIssuesWithoutEpicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EpicAPIService) GetIssuesWithoutEpicExecute(r ApiGetIssuesWithoutEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.GetIssuesWithoutEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/none/issue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMoveIssuesToEpicRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	epicIdOrKey string
	moveIssuesToBacklogRequest *MoveIssuesToBacklogRequest
}

func (r ApiMoveIssuesToEpicRequest) MoveIssuesToBacklogRequest(moveIssuesToBacklogRequest MoveIssuesToBacklogRequest) ApiMoveIssuesToEpicRequest {
	r.moveIssuesToBacklogRequest = &moveIssuesToBacklogRequest
	return r
}

func (r ApiMoveIssuesToEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveIssuesToEpicExecute(r)
}

/*
MoveIssuesToEpic Move issues to epic

Moves issues to an epic, for a given epic id. Issues can be only in a single epic at the same time. That means that already assigned issues to an epic, will not be assigned to the previous epic anymore. The user needs to have the edit issue permission for all issue they want to move and to the epic. The maximum number of issues that can be moved in one operation is 50. **Note:** This operation does not work for epics in next-gen projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param epicIdOrKey The id or key of the epic that you want to assign issues to.
 @return ApiMoveIssuesToEpicRequest
*/
func (a *EpicAPIService) MoveIssuesToEpic(ctx context.Context, epicIdOrKey string) ApiMoveIssuesToEpicRequest {
	return ApiMoveIssuesToEpicRequest{
		ApiService: a,
		ctx: ctx,
		epicIdOrKey: epicIdOrKey,
	}
}

// Execute executes the request
func (a *EpicAPIService) MoveIssuesToEpicExecute(r ApiMoveIssuesToEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.MoveIssuesToEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/{epicIdOrKey}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"epicIdOrKey"+"}", url.PathEscape(parameterValueToString(r.epicIdOrKey, "epicIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogRequest == nil {
		return nil, reportError("moveIssuesToBacklogRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPartiallyUpdateEpicRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	epicIdOrKey string
	partiallyUpdateEpicRequest *PartiallyUpdateEpicRequest
}

func (r ApiPartiallyUpdateEpicRequest) PartiallyUpdateEpicRequest(partiallyUpdateEpicRequest PartiallyUpdateEpicRequest) ApiPartiallyUpdateEpicRequest {
	r.partiallyUpdateEpicRequest = &partiallyUpdateEpicRequest
	return r
}

func (r ApiPartiallyUpdateEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.PartiallyUpdateEpicExecute(r)
}

/*
PartiallyUpdateEpic Partially update epic

Performs a partial update of the epic. A partial update means that fields not present in the request JSON will not be updated. Valid values for color are `color_1` to `color_9`. **Note:** This operation does not work for epics in next-gen projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param epicIdOrKey The id or key of the epic to update.
 @return ApiPartiallyUpdateEpicRequest
*/
func (a *EpicAPIService) PartiallyUpdateEpic(ctx context.Context, epicIdOrKey string) ApiPartiallyUpdateEpicRequest {
	return ApiPartiallyUpdateEpicRequest{
		ApiService: a,
		ctx: ctx,
		epicIdOrKey: epicIdOrKey,
	}
}

// Execute executes the request
func (a *EpicAPIService) PartiallyUpdateEpicExecute(r ApiPartiallyUpdateEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.PartiallyUpdateEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/{epicIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"epicIdOrKey"+"}", url.PathEscape(parameterValueToString(r.epicIdOrKey, "epicIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partiallyUpdateEpicRequest == nil {
		return nil, reportError("partiallyUpdateEpicRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partiallyUpdateEpicRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRankEpicsRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	epicIdOrKey string
	rankEpicsRequest *RankEpicsRequest
}

// bean which contains the information where the given epic should be ranked.
func (r ApiRankEpicsRequest) RankEpicsRequest(rankEpicsRequest RankEpicsRequest) ApiRankEpicsRequest {
	r.rankEpicsRequest = &rankEpicsRequest
	return r
}

func (r ApiRankEpicsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEpicsExecute(r)
}

/*
RankEpics Rank epics

Moves (ranks) an epic before or after a given epic.

If rankCustomFieldId is not defined, the default rank field will be used.

**Note:** This operation does not work for epics in next-gen projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param epicIdOrKey The id or key of the epic to rank.
 @return ApiRankEpicsRequest
*/
func (a *EpicAPIService) RankEpics(ctx context.Context, epicIdOrKey string) ApiRankEpicsRequest {
	return ApiRankEpicsRequest{
		ApiService: a,
		ctx: ctx,
		epicIdOrKey: epicIdOrKey,
	}
}

// Execute executes the request
func (a *EpicAPIService) RankEpicsExecute(r ApiRankEpicsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.RankEpics")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/{epicIdOrKey}/rank"
	localVarPath = strings.Replace(localVarPath, "{"+"epicIdOrKey"+"}", url.PathEscape(parameterValueToString(r.epicIdOrKey, "epicIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rankEpicsRequest == nil {
		return nil, reportError("rankEpicsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rankEpicsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveIssuesFromEpicRequest struct {
	ctx context.Context
	ApiService *EpicAPIService
	moveIssuesToBacklogRequest *MoveIssuesToBacklogRequest
}

func (r ApiRemoveIssuesFromEpicRequest) MoveIssuesToBacklogRequest(moveIssuesToBacklogRequest MoveIssuesToBacklogRequest) ApiRemoveIssuesFromEpicRequest {
	r.moveIssuesToBacklogRequest = &moveIssuesToBacklogRequest
	return r
}

func (r ApiRemoveIssuesFromEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveIssuesFromEpicExecute(r)
}

/*
RemoveIssuesFromEpic Remove issues from epic

Removes issues from epics. The user needs to have the edit issue permission for all issue they want to remove from epics. The maximum number of issues that can be moved in one operation is 50. **Note:** This operation does not work for epics in next-gen projects. Instead, update the issue using `\{ fields: \{ parent: \{\} \} \}`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveIssuesFromEpicRequest
*/
func (a *EpicAPIService) RemoveIssuesFromEpic(ctx context.Context) ApiRemoveIssuesFromEpicRequest {
	return ApiRemoveIssuesFromEpicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EpicAPIService) RemoveIssuesFromEpicExecute(r ApiRemoveIssuesFromEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EpicAPIService.RemoveIssuesFromEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/epic/none/issue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogRequest == nil {
		return nil, reportError("moveIssuesToBacklogRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
