/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DevOpsComponentsAPIService DevOpsComponentsAPI service
type DevOpsComponentsAPIService service

type ApiDeleteComponentByIdRequest struct {
	ctx context.Context
	ApiService *DevOpsComponentsAPIService
	authorization *string
	componentId string
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Operations Information module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiDeleteComponentByIdRequest) Authorization(authorization string) ApiDeleteComponentByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteComponentByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteComponentByIdExecute(r)
}

/*
DeleteComponentById Delete a Component by ID

Delete the Component data currently stored for the given ID.

Deletion is performed asynchronously. The getComponentById operation can be used to confirm that data has been deleted successfully (if needed).

Only Connect apps that define the `jiraDevOpsComponentProvider` module can access this resource.
This resource requires the 'DELETE' scope for Connect apps.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The ID of the Component to delete. 
 @return ApiDeleteComponentByIdRequest
*/
func (a *DevOpsComponentsAPIService) DeleteComponentById(ctx context.Context, componentId string) ApiDeleteComponentByIdRequest {
	return ApiDeleteComponentByIdRequest{
		ApiService: a,
		ctx: ctx,
		componentId: componentId,
	}
}

// Execute executes the request
func (a *DevOpsComponentsAPIService) DeleteComponentByIdExecute(r ApiDeleteComponentByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsComponentsAPIService.DeleteComponentById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/devopscomponents/1.0/devopscomponents/{componentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterValueToString(r.componentId, "componentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.componentId) > 255 {
		return nil, reportError("componentId must have less than 255 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteComponentsByPropertyRequest struct {
	ctx context.Context
	ApiService *DevOpsComponentsAPIService
	authorization *string
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Operations Information module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiDeleteComponentsByPropertyRequest) Authorization(authorization string) ApiDeleteComponentsByPropertyRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteComponentsByPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteComponentsByPropertyExecute(r)
}

/*
DeleteComponentsByProperty Delete DevOps Components by Property

Bulk delete all Components that match the given request.

One or more query params must be supplied to specify Properties to delete by.
If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND).
See the documentation for the submitComponents operation for more details.

e.g. DELETE /bulkByProperties?accountId=account-123&createdBy=user-456

Deletion is performed asynchronously. The getComponentById operation can be used to confirm that data has been deleted successfully (if needed).

Only Connect apps that define the `jiraDevOpsComponentProvider` module can access this resource.
This resource requires the 'DELETE' scope for Connect apps.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteComponentsByPropertyRequest
*/
func (a *DevOpsComponentsAPIService) DeleteComponentsByProperty(ctx context.Context) ApiDeleteComponentsByPropertyRequest {
	return ApiDeleteComponentsByPropertyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DevOpsComponentsAPIService) DeleteComponentsByPropertyExecute(r ApiDeleteComponentsByPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsComponentsAPIService.DeleteComponentsByProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/devopscomponents/1.0/bulkByProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetComponentByIdRequest struct {
	ctx context.Context
	ApiService *DevOpsComponentsAPIService
	authorization *string
	componentId string
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Operations Information module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiGetComponentByIdRequest) Authorization(authorization string) ApiGetComponentByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetComponentByIdRequest) Execute() (*GetComponentById200Response, *http.Response, error) {
	return r.ApiService.GetComponentByIdExecute(r)
}

/*
GetComponentById Get a Component by ID

Retrieve the currently stored Component data for the given ID.

The result will be what is currently stored, ignoring any pending updates or deletes.

Only Connect apps that define the `jiraDevOpsComponentProvider` module can access this resource.
This resource requires the 'READ' scope for Connect apps.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The ID of the Component to fetch. 
 @return ApiGetComponentByIdRequest
*/
func (a *DevOpsComponentsAPIService) GetComponentById(ctx context.Context, componentId string) ApiGetComponentByIdRequest {
	return ApiGetComponentByIdRequest{
		ApiService: a,
		ctx: ctx,
		componentId: componentId,
	}
}

// Execute executes the request
//  @return GetComponentById200Response
func (a *DevOpsComponentsAPIService) GetComponentByIdExecute(r ApiGetComponentByIdRequest) (*GetComponentById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetComponentById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsComponentsAPIService.GetComponentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/devopscomponents/1.0/devopscomponents/{componentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterValueToString(r.componentId, "componentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.componentId) > 255 {
		return localVarReturnValue, nil, reportError("componentId must have less than 255 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitComponentsRequest struct {
	ctx context.Context
	ApiService *DevOpsComponentsAPIService
	authorization *string
	submitDevopsComponentsRequest *SubmitDevopsComponentsRequest
}

// All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the DevOps Information module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details. 
func (r ApiSubmitComponentsRequest) Authorization(authorization string) ApiSubmitComponentsRequest {
	r.authorization = &authorization
	return r
}

// DevOps Component data to submit. 
func (r ApiSubmitComponentsRequest) SubmitDevopsComponentsRequest(submitDevopsComponentsRequest SubmitDevopsComponentsRequest) ApiSubmitComponentsRequest {
	r.submitDevopsComponentsRequest = &submitDevopsComponentsRequest
	return r
}

func (r ApiSubmitComponentsRequest) Execute() (*SubmitDevopsComponentsResponse, *http.Response, error) {
	return r.ApiService.SubmitComponentsExecute(r)
}

/*
SubmitComponents Submit DevOps Components

Update / insert DevOps Component data.

Components are identified by their ID, and existing Component data for the same ID will be replaced if it exists and the updateSequenceNumber of existing data is less than the incoming data.

Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are available within a short period of time, but may take some time during peak load and/or maintenance times. The getComponentById operation can be used to confirm that data has been stored successfully (if needed).

In the case of multiple Components being submitted in one request, each is validated individually prior to submission. Details of which Components failed submission (if any) are available in the response object.

A maximum of 1000 components can be submitted in one request.

Only Connect apps that define the `jiraDevOpsComponentProvider` module can access this resource.
This resource requires the 'WRITE' scope for Connect apps.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitComponentsRequest
*/
func (a *DevOpsComponentsAPIService) SubmitComponents(ctx context.Context) ApiSubmitComponentsRequest {
	return ApiSubmitComponentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitDevopsComponentsResponse
func (a *DevOpsComponentsAPIService) SubmitComponentsExecute(r ApiSubmitComponentsRequest) (*SubmitDevopsComponentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitDevopsComponentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsComponentsAPIService.SubmitComponents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/devopscomponents/1.0/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.submitDevopsComponentsRequest == nil {
		return localVarReturnValue, nil, reportError("submitDevopsComponentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.submitDevopsComponentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v []ErrorMessage1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
