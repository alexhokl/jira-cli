/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BuildsAPIService BuildsAPI service
type BuildsAPIService service

type ApiDeleteBuildByKeyRequest struct {
	ctx context.Context
	ApiService *BuildsAPIService
	authorization *string
	pipelineId string
	buildNumber int64
	updateSequenceNumber *int64
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraBuildInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiDeleteBuildByKeyRequest) Authorization(authorization string) ApiDeleteBuildByKeyRequest {
	r.authorization = &authorization
	return r
}

// This parameter usage is no longer supported.  An optional &#x60;_updateSequenceNumber&#x60; to use to control deletion.  Only stored data with an &#x60;updateSequenceNumber&#x60; less than or equal to that provided will be deleted. This can be used help ensure submit/delete requests are applied correctly if issued close together. 
// Deprecated
func (r ApiDeleteBuildByKeyRequest) UpdateSequenceNumber(updateSequenceNumber int64) ApiDeleteBuildByKeyRequest {
	r.updateSequenceNumber = &updateSequenceNumber
	return r
}

func (r ApiDeleteBuildByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBuildByKeyExecute(r)
}

/*
DeleteBuildByKey Delete a build by key

Delete the build data currently stored for the given `pipelineId` and `buildNumber` combination.

Deletion is performed asynchronously. The `getBuildByKey` operation can be used to confirm that data has been
deleted successfully (if needed).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pipelineId The `pipelineId` of the build to delete. 
 @param buildNumber The `buildNumber` of the build to delete. 
 @return ApiDeleteBuildByKeyRequest
*/
func (a *BuildsAPIService) DeleteBuildByKey(ctx context.Context, pipelineId string, buildNumber int64) ApiDeleteBuildByKeyRequest {
	return ApiDeleteBuildByKeyRequest{
		ApiService: a,
		ctx: ctx,
		pipelineId: pipelineId,
		buildNumber: buildNumber,
	}
}

// Execute executes the request
func (a *BuildsAPIService) DeleteBuildByKeyExecute(r ApiDeleteBuildByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAPIService.DeleteBuildByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/builds/0.1/pipelines/{pipelineId}/builds/{buildNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"pipelineId"+"}", url.PathEscape(parameterValueToString(r.pipelineId, "pipelineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"buildNumber"+"}", url.PathEscape(parameterValueToString(r.buildNumber, "buildNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.pipelineId) > 255 {
		return nil, reportError("pipelineId must have less than 255 elements")
	}

	if r.updateSequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_updateSequenceNumber", r.updateSequenceNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBuildsByPropertyRequest struct {
	ctx context.Context
	ApiService *BuildsAPIService
	authorization *string
	updateSequenceNumber *int64
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraBuildInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiDeleteBuildsByPropertyRequest) Authorization(authorization string) ApiDeleteBuildsByPropertyRequest {
	r.authorization = &authorization
	return r
}

// This parameter usage is no longer supported.  An optional &#x60;_updateSequenceNumber&#x60; to use to control deletion.  Only stored data with an &#x60;updateSequenceNumber&#x60; less than or equal to that provided will be deleted. This can be used help ensure submit/delete requests are applied correctly if issued close together.  If not provided, all stored data that matches the request will be deleted. 
// Deprecated
func (r ApiDeleteBuildsByPropertyRequest) UpdateSequenceNumber(updateSequenceNumber int64) ApiDeleteBuildsByPropertyRequest {
	r.updateSequenceNumber = &updateSequenceNumber
	return r
}

func (r ApiDeleteBuildsByPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBuildsByPropertyExecute(r)
}

/*
DeleteBuildsByProperty Delete builds by Property

Bulk delete all builds data that match the given request.

One or more query params must be supplied to specify Properties to delete by.
Optional param `_updateSequenceNumber` is no longer supported.
If more than one Property is provided, data will be deleted that matches ALL of the
Properties (e.g. treated as an AND).

See the documentation for the `submitBuilds` operation for more details.

e.g. DELETE /bulkByProperties?accountId=account-123&repoId=repo-345

Deletion is performed asynchronously. The `getBuildByKey` operation can be used to confirm that data has been
deleted successfully (if needed).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBuildsByPropertyRequest
*/
func (a *BuildsAPIService) DeleteBuildsByProperty(ctx context.Context) ApiDeleteBuildsByPropertyRequest {
	return ApiDeleteBuildsByPropertyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BuildsAPIService) DeleteBuildsByPropertyExecute(r ApiDeleteBuildsByPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAPIService.DeleteBuildsByProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/builds/0.1/bulkByProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.updateSequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_updateSequenceNumber", r.updateSequenceNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBuildByKeyRequest struct {
	ctx context.Context
	ApiService *BuildsAPIService
	authorization *string
	pipelineId string
	buildNumber int64
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraBuildInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiGetBuildByKeyRequest) Authorization(authorization string) ApiGetBuildByKeyRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetBuildByKeyRequest) Execute() (*BuildData, *http.Response, error) {
	return r.ApiService.GetBuildByKeyExecute(r)
}

/*
GetBuildByKey Get a build by key

Retrieve the currently stored build data for the given `pipelineId` and `buildNumber` combination.

The result will be what is currently stored, ignoring any pending updates or deletes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pipelineId The `pipelineId` of the build. 
 @param buildNumber The `buildNumber` of the build. 
 @return ApiGetBuildByKeyRequest
*/
func (a *BuildsAPIService) GetBuildByKey(ctx context.Context, pipelineId string, buildNumber int64) ApiGetBuildByKeyRequest {
	return ApiGetBuildByKeyRequest{
		ApiService: a,
		ctx: ctx,
		pipelineId: pipelineId,
		buildNumber: buildNumber,
	}
}

// Execute executes the request
//  @return BuildData
func (a *BuildsAPIService) GetBuildByKeyExecute(r ApiGetBuildByKeyRequest) (*BuildData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BuildData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAPIService.GetBuildByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/builds/0.1/pipelines/{pipelineId}/builds/{buildNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"pipelineId"+"}", url.PathEscape(parameterValueToString(r.pipelineId, "pipelineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"buildNumber"+"}", url.PathEscape(parameterValueToString(r.buildNumber, "buildNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.pipelineId) > 255 {
		return localVarReturnValue, nil, reportError("pipelineId must have less than 255 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitBuildsRequest struct {
	ctx context.Context
	ApiService *BuildsAPIService
	authorization *string
	submitBuildsRequest *SubmitBuildsRequest
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraBuildInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiSubmitBuildsRequest) Authorization(authorization string) ApiSubmitBuildsRequest {
	r.authorization = &authorization
	return r
}

// Builds data to submit. 
func (r ApiSubmitBuildsRequest) SubmitBuildsRequest(submitBuildsRequest SubmitBuildsRequest) ApiSubmitBuildsRequest {
	r.submitBuildsRequest = &submitBuildsRequest
	return r
}

func (r ApiSubmitBuildsRequest) Execute() (*SubmitBuildsResponse, *http.Response, error) {
	return r.ApiService.SubmitBuildsExecute(r)
}

/*
SubmitBuilds Submit build data

Update / insert builds data.

Builds are identified by the combination of `pipelineId` and `buildNumber`, and existing build data for the same
build will be replaced if it exists and the `updateSequenceNumber` of the existing data is less than the
incoming data.

Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are
available within a short period of time, but may take some time during peak load and/or maintenance times.
The `getBuildByKey` operation can be used to confirm that data has been stored successfully (if needed).

In the case of multiple builds being submitted in one request, each is validated individually prior to
submission. Details of which build failed submission (if any) are available in the response object.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitBuildsRequest
*/
func (a *BuildsAPIService) SubmitBuilds(ctx context.Context) ApiSubmitBuildsRequest {
	return ApiSubmitBuildsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitBuildsResponse
func (a *BuildsAPIService) SubmitBuildsExecute(r ApiSubmitBuildsRequest) (*SubmitBuildsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitBuildsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAPIService.SubmitBuilds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/builds/0.1/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.submitBuildsRequest == nil {
		return localVarReturnValue, nil, reportError("submitBuildsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.submitBuildsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v []ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
