/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RemoteLinksAPIService RemoteLinksAPI service
type RemoteLinksAPIService service

type ApiDeleteRemoteLinkByIdRequest struct {
	ctx context.Context
	ApiService *RemoteLinksAPIService
	authorization *string
	remoteLinkId string
	updateSequenceNumber *int64
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraRemoteLinkInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiDeleteRemoteLinkByIdRequest) Authorization(authorization string) ApiDeleteRemoteLinkByIdRequest {
	r.authorization = &authorization
	return r
}

// This parameter usage is no longer supported.  An optional &#x60;_updateSequenceNumber&#x60; to use to control deletion.  Only stored data with an &#x60;updateSequenceNumber&#x60; less than or equal to that provided will be deleted. This can be used help ensure submit/delete requests are applied correctly if issued close together. 
// Deprecated
func (r ApiDeleteRemoteLinkByIdRequest) UpdateSequenceNumber(updateSequenceNumber int64) ApiDeleteRemoteLinkByIdRequest {
	r.updateSequenceNumber = &updateSequenceNumber
	return r
}

func (r ApiDeleteRemoteLinkByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRemoteLinkByIdExecute(r)
}

/*
DeleteRemoteLinkById Delete a Remote Link by ID

Delete the Remote Link data currently stored for the given ID.

Deletion is performed asynchronously. The `getRemoteLinkById` operation can be used to confirm that data has been
deleted successfully (if needed).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param remoteLinkId The ID of the Remote Link to fetch. 
 @return ApiDeleteRemoteLinkByIdRequest
*/
func (a *RemoteLinksAPIService) DeleteRemoteLinkById(ctx context.Context, remoteLinkId string) ApiDeleteRemoteLinkByIdRequest {
	return ApiDeleteRemoteLinkByIdRequest{
		ApiService: a,
		ctx: ctx,
		remoteLinkId: remoteLinkId,
	}
}

// Execute executes the request
func (a *RemoteLinksAPIService) DeleteRemoteLinkByIdExecute(r ApiDeleteRemoteLinkByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteLinksAPIService.DeleteRemoteLinkById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/remotelinks/1.0/remotelink/{remoteLinkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"remoteLinkId"+"}", url.PathEscape(parameterValueToString(r.remoteLinkId, "remoteLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.remoteLinkId) > 255 {
		return nil, reportError("remoteLinkId must have less than 255 elements")
	}

	if r.updateSequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_updateSequenceNumber", r.updateSequenceNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRemoteLinksByPropertyRequest struct {
	ctx context.Context
	ApiService *RemoteLinksAPIService
	authorization *string
	updateSequenceNumber *int64
	params *map[string]interface{}
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraRemoteLinkInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiDeleteRemoteLinksByPropertyRequest) Authorization(authorization string) ApiDeleteRemoteLinksByPropertyRequest {
	r.authorization = &authorization
	return r
}

// This parameter usage is no longer supported.  An optional &#x60;_updateSequenceNumber&#x60; to use to control deletion.  Only stored data with an &#x60;updateSequenceNumber&#x60; less than or equal to that provided will be deleted. This can be used help ensure submit/delete requests are applied correctly if issued close together.  If not provided, all stored data that matches the request will be deleted. 
// Deprecated
func (r ApiDeleteRemoteLinksByPropertyRequest) UpdateSequenceNumber(updateSequenceNumber int64) ApiDeleteRemoteLinksByPropertyRequest {
	r.updateSequenceNumber = &updateSequenceNumber
	return r
}

// Free-form query parameters to specify which properties to delete by. Properties refer to the arbitrary information the provider tagged Remote Links with previously.  For example, if the provider previously tagged a remote link with accountId:   \&quot;properties\&quot;: {     \&quot;accountId\&quot;: \&quot;account-123\&quot;   }  And now they want to delete Remote Links in bulk by that specific accountId as follows: e.g. DELETE /bulkByProperties?accountId&#x3D;account-123 
func (r ApiDeleteRemoteLinksByPropertyRequest) Params(params map[string]interface{}) ApiDeleteRemoteLinksByPropertyRequest {
	r.params = &params
	return r
}

func (r ApiDeleteRemoteLinksByPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRemoteLinksByPropertyExecute(r)
}

/*
DeleteRemoteLinksByProperty Delete Remote Links by Property

Bulk delete all Remote Links data that match the given request.

One or more query params must be supplied to specify Properties to delete by.
Optional param `_updateSequenceNumber` is no longer supported. If more than one Property is provided,
data will be deleted that matches ALL of the Properties (e.g. treated as an AND).

See the documentation for the `submitRemoteLinks` operation for more details.

e.g. DELETE /bulkByProperties?accountId=account-123&repoId=repo-345

Deletion is performed asynchronously. The `getRemoteLinkById` operation can be used to confirm that data has been
deleted successfully (if needed).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRemoteLinksByPropertyRequest
*/
func (a *RemoteLinksAPIService) DeleteRemoteLinksByProperty(ctx context.Context) ApiDeleteRemoteLinksByPropertyRequest {
	return ApiDeleteRemoteLinksByPropertyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RemoteLinksAPIService) DeleteRemoteLinksByPropertyExecute(r ApiDeleteRemoteLinksByPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteLinksAPIService.DeleteRemoteLinksByProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/remotelinks/1.0/bulkByProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.updateSequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_updateSequenceNumber", r.updateSequenceNumber, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRemoteLinkByIdRequest struct {
	ctx context.Context
	ApiService *RemoteLinksAPIService
	authorization *string
	remoteLinkId string
}

// All requests must be signed with either a Connect JWT token or OAuth token for an on-premise integration that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraRemoteLinkInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiGetRemoteLinkByIdRequest) Authorization(authorization string) ApiGetRemoteLinkByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetRemoteLinkByIdRequest) Execute() (*RemoteLinkData, *http.Response, error) {
	return r.ApiService.GetRemoteLinkByIdExecute(r)
}

/*
GetRemoteLinkById Get a Remote Link by ID

Retrieve the currently stored Remote Link data for the given ID.

The result will be what is currently stored, ignoring any pending updates or deletes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param remoteLinkId The ID of the Remote Link to fetch. 
 @return ApiGetRemoteLinkByIdRequest
*/
func (a *RemoteLinksAPIService) GetRemoteLinkById(ctx context.Context, remoteLinkId string) ApiGetRemoteLinkByIdRequest {
	return ApiGetRemoteLinkByIdRequest{
		ApiService: a,
		ctx: ctx,
		remoteLinkId: remoteLinkId,
	}
}

// Execute executes the request
//  @return RemoteLinkData
func (a *RemoteLinksAPIService) GetRemoteLinkByIdExecute(r ApiGetRemoteLinkByIdRequest) (*RemoteLinkData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoteLinkData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteLinksAPIService.GetRemoteLinkById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/remotelinks/1.0/remotelink/{remoteLinkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"remoteLinkId"+"}", url.PathEscape(parameterValueToString(r.remoteLinkId, "remoteLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(r.remoteLinkId) > 255 {
		return localVarReturnValue, nil, reportError("remoteLinkId must have less than 255 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitRemoteLinksRequest struct {
	ctx context.Context
	ApiService *RemoteLinksAPIService
	authorization *string
	submitRemoteLinksRequest *SubmitRemoteLinksRequest
}

// All requests must be signed with a Connect JWT token that corresponds to an app installed in Jira.  If the Connect JWT token corresponds to an app that does not define &#x60;jiraRemoteLinkInfoProvider&#x60; module it will be rejected with a 403.  See https://developer.atlassian.com/blog/2015/01/understanding-jwt/ for more details about Connect JWT tokens. See https://developer.atlassian.com/cloud/jira/software/integrate-jsw-cloud-with-onpremises-tools/ for details about on-premise integrations. 
func (r ApiSubmitRemoteLinksRequest) Authorization(authorization string) ApiSubmitRemoteLinksRequest {
	r.authorization = &authorization
	return r
}

// Remote Links data to submit. 
func (r ApiSubmitRemoteLinksRequest) SubmitRemoteLinksRequest(submitRemoteLinksRequest SubmitRemoteLinksRequest) ApiSubmitRemoteLinksRequest {
	r.submitRemoteLinksRequest = &submitRemoteLinksRequest
	return r
}

func (r ApiSubmitRemoteLinksRequest) Execute() (*SubmitRemoteLinks202Response, *http.Response, error) {
	return r.ApiService.SubmitRemoteLinksExecute(r)
}

/*
SubmitRemoteLinks Submit Remote Link data

Update / insert Remote Link data.

Remote Links are identified by their ID, existing Remote Link data for the same ID will be replaced if it
exists and the updateSequenceId of existing data is less than the incoming data.

Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are
available within a short period of time, but may take some time during peak load and/or maintenance times.
The `getRemoteLinkById` operation can be used to confirm that data has been stored successfully (if needed).

In the case of multiple Remote Links being submitted in one request, each is validated individually prior to
submission. Details of which Remote LInk failed submission (if any) are available in the response object.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitRemoteLinksRequest
*/
func (a *RemoteLinksAPIService) SubmitRemoteLinks(ctx context.Context) ApiSubmitRemoteLinksRequest {
	return ApiSubmitRemoteLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitRemoteLinks202Response
func (a *RemoteLinksAPIService) SubmitRemoteLinksExecute(r ApiSubmitRemoteLinksRequest) (*SubmitRemoteLinks202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitRemoteLinks202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteLinksAPIService.SubmitRemoteLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/remotelinks/1.0/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.submitRemoteLinksRequest == nil {
		return localVarReturnValue, nil, reportError("submitRemoteLinksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.submitRemoteLinksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v []SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
