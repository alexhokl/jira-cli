/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BacklogAPIService BacklogAPI service
type BacklogAPIService service

type ApiMoveIssuesToBacklogRequest struct {
	ctx context.Context
	ApiService *BacklogAPIService
	moveIssuesToBacklogRequest *MoveIssuesToBacklogRequest
}

func (r ApiMoveIssuesToBacklogRequest) MoveIssuesToBacklogRequest(moveIssuesToBacklogRequest MoveIssuesToBacklogRequest) ApiMoveIssuesToBacklogRequest {
	r.moveIssuesToBacklogRequest = &moveIssuesToBacklogRequest
	return r
}

func (r ApiMoveIssuesToBacklogRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveIssuesToBacklogExecute(r)
}

/*
MoveIssuesToBacklog Move issues to backlog

Move issues to the backlog.  
This operation is equivalent to remove future and active sprints from a given set of issues. At most 50 issues may be moved at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoveIssuesToBacklogRequest
*/
func (a *BacklogAPIService) MoveIssuesToBacklog(ctx context.Context) ApiMoveIssuesToBacklogRequest {
	return ApiMoveIssuesToBacklogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BacklogAPIService) MoveIssuesToBacklogExecute(r ApiMoveIssuesToBacklogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BacklogAPIService.MoveIssuesToBacklog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/backlog/issue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogRequest == nil {
		return nil, reportError("moveIssuesToBacklogRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMoveIssuesToBacklogForBoardRequest struct {
	ctx context.Context
	ApiService *BacklogAPIService
	boardId int64
	moveIssuesToBacklogForBoardRequest *MoveIssuesToBacklogForBoardRequest
}

func (r ApiMoveIssuesToBacklogForBoardRequest) MoveIssuesToBacklogForBoardRequest(moveIssuesToBacklogForBoardRequest MoveIssuesToBacklogForBoardRequest) ApiMoveIssuesToBacklogForBoardRequest {
	r.moveIssuesToBacklogForBoardRequest = &moveIssuesToBacklogForBoardRequest
	return r
}

func (r ApiMoveIssuesToBacklogForBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveIssuesToBacklogForBoardExecute(r)
}

/*
MoveIssuesToBacklogForBoard Move issues to backlog for board

Move issues to the backlog of a particular board (if they are already on that board).  
This operation is equivalent to remove future and active sprints from a given set of issues if the board has sprints If the board does not have sprints this will put the issues back into the backlog from the board. At most 50 issues may be moved at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId
 @return ApiMoveIssuesToBacklogForBoardRequest
*/
func (a *BacklogAPIService) MoveIssuesToBacklogForBoard(ctx context.Context, boardId int64) ApiMoveIssuesToBacklogForBoardRequest {
	return ApiMoveIssuesToBacklogForBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BacklogAPIService) MoveIssuesToBacklogForBoardExecute(r ApiMoveIssuesToBacklogForBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BacklogAPIService.MoveIssuesToBacklogForBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/backlog/{boardId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogForBoardRequest == nil {
		return nil, reportError("moveIssuesToBacklogForBoardRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogForBoardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
