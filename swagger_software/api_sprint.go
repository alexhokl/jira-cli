/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SprintAPIService SprintAPI service
type SprintAPIService service

type ApiCreateSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	createSprintRequest *CreateSprintRequest
}

func (r ApiCreateSprintRequest) CreateSprintRequest(createSprintRequest CreateSprintRequest) ApiCreateSprintRequest {
	r.createSprintRequest = &createSprintRequest
	return r
}

func (r ApiCreateSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSprintExecute(r)
}

/*
CreateSprint Create sprint

Creates a future sprint. Sprint name and origin board id are required. Start date, end date, and goal are optional.

Note that the sprint name is trimmed. Also, when starting sprints from the UI, the "endDate" set through this call is ignored and instead the last sprint's duration is used to fill the form.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSprintRequest
*/
func (a *SprintAPIService) CreateSprint(ctx context.Context) ApiCreateSprintRequest {
	return ApiCreateSprintRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SprintAPIService) CreateSprintExecute(r ApiCreateSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.CreateSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSprintRequest == nil {
		return nil, reportError("createSprintRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSprintRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePropertyRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId string
	propertyKey string
}

func (r ApiDeletePropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePropertyExecute(r)
}

/*
DeleteProperty Delete property

Removes the property from the sprint identified by the id. Ths user removing the property is required to have permissions to modify the sprint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId the ID of the sprint from which the property will be removed.
 @param propertyKey the key of the property to remove.
 @return ApiDeletePropertyRequest
*/
func (a *SprintAPIService) DeleteProperty(ctx context.Context, sprintId string, propertyKey string) ApiDeletePropertyRequest {
	return ApiDeletePropertyRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
		propertyKey: propertyKey,
	}
}

// Execute executes the request
func (a *SprintAPIService) DeletePropertyExecute(r ApiDeletePropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.DeleteProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/properties/{propertyKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyKey"+"}", url.PathEscape(parameterValueToString(r.propertyKey, "propertyKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
}

func (r ApiDeleteSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSprintExecute(r)
}

/*
DeleteSprint Delete sprint

Deletes a sprint. Once a sprint is deleted, all open issues in the sprint will be moved to the backlog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId The ID of the sprint to delete.
 @return ApiDeleteSprintRequest
*/
func (a *SprintAPIService) DeleteSprint(ctx context.Context, sprintId int64) ApiDeleteSprintRequest {
	return ApiDeleteSprintRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) DeleteSprintExecute(r ApiDeleteSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.DeleteSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIssuesForSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetIssuesForSprintRequest) StartAt(startAt int64) ApiGetIssuesForSprintRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetIssuesForSprintRequest) MaxResults(maxResults int32) ApiGetIssuesForSprintRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.   Note that &#x60;username&#x60; and &#x60;userkey&#x60; can&#39;t be used as search terms for this parameter due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetIssuesForSprintRequest) Jql(jql string) ApiGetIssuesForSprintRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetIssuesForSprintRequest) ValidateQuery(validateQuery bool) ApiGetIssuesForSprintRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssuesForSprintRequest) Fields(fields []map[string]interface{}) ApiGetIssuesForSprintRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetIssuesForSprintRequest) Expand(expand string) ApiGetIssuesForSprintRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssuesForSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetIssuesForSprintExecute(r)
}

/*
GetIssuesForSprint Get issues for sprint

Returns all issues in a sprint, for a given sprint ID. This only includes issues that the user has permission to view. By default, the returned issues are ordered by rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId The ID of the sprint that contains the requested issues.
 @return ApiGetIssuesForSprintRequest
*/
func (a *SprintAPIService) GetIssuesForSprint(ctx context.Context, sprintId int64) ApiGetIssuesForSprintRequest {
	return ApiGetIssuesForSprintRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) GetIssuesForSprintExecute(r ApiGetIssuesForSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.GetIssuesForSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPropertiesKeysRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId string
}

func (r ApiGetPropertiesKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPropertiesKeysExecute(r)
}

/*
GetPropertiesKeys Get properties keys

Returns the keys of all properties for the sprint identified by the id. The user who retrieves the property keys is required to have permissions to view the sprint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId the ID of the sprint from which property keys will be returned.
 @return ApiGetPropertiesKeysRequest
*/
func (a *SprintAPIService) GetPropertiesKeys(ctx context.Context, sprintId string) ApiGetPropertiesKeysRequest {
	return ApiGetPropertiesKeysRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) GetPropertiesKeysExecute(r ApiGetPropertiesKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.GetPropertiesKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPropertyRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId string
	propertyKey string
}

func (r ApiGetPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPropertyExecute(r)
}

/*
GetProperty Get property

Returns the value of the property with a given key from the sprint identified by the provided id. The user who retrieves the property is required to have permissions to view the sprint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId the ID of the sprint from which the property will be returned.
 @param propertyKey the key of the property to return.
 @return ApiGetPropertyRequest
*/
func (a *SprintAPIService) GetProperty(ctx context.Context, sprintId string, propertyKey string) ApiGetPropertyRequest {
	return ApiGetPropertyRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
		propertyKey: propertyKey,
	}
}

// Execute executes the request
func (a *SprintAPIService) GetPropertyExecute(r ApiGetPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.GetProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/properties/{propertyKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyKey"+"}", url.PathEscape(parameterValueToString(r.propertyKey, "propertyKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
}

func (r ApiGetSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSprintExecute(r)
}

/*
GetSprint Get sprint

Returns the sprint for a given sprint ID. The sprint will only be returned if the user can view the board that the sprint was created on, or view at least one of the issues in the sprint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId The ID of the requested sprint.
 @return ApiGetSprintRequest
*/
func (a *SprintAPIService) GetSprint(ctx context.Context, sprintId int64) ApiGetSprintRequest {
	return ApiGetSprintRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) GetSprintExecute(r ApiGetSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.GetSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMoveIssuesToSprintAndRankRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
	moveIssuesToBacklogForBoardRequest *MoveIssuesToBacklogForBoardRequest
}

func (r ApiMoveIssuesToSprintAndRankRequest) MoveIssuesToBacklogForBoardRequest(moveIssuesToBacklogForBoardRequest MoveIssuesToBacklogForBoardRequest) ApiMoveIssuesToSprintAndRankRequest {
	r.moveIssuesToBacklogForBoardRequest = &moveIssuesToBacklogForBoardRequest
	return r
}

func (r ApiMoveIssuesToSprintAndRankRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveIssuesToSprintAndRankExecute(r)
}

/*
MoveIssuesToSprintAndRank Move issues to sprint and rank

Moves issues to a sprint, for a given sprint ID. Issues can only be moved to open or active sprints. The maximum number of issues that can be moved in one operation is 50.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId The ID of the sprint that you want to assign issues to.
 @return ApiMoveIssuesToSprintAndRankRequest
*/
func (a *SprintAPIService) MoveIssuesToSprintAndRank(ctx context.Context, sprintId int64) ApiMoveIssuesToSprintAndRankRequest {
	return ApiMoveIssuesToSprintAndRankRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) MoveIssuesToSprintAndRankExecute(r ApiMoveIssuesToSprintAndRankRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.MoveIssuesToSprintAndRank")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogForBoardRequest == nil {
		return nil, reportError("moveIssuesToBacklogForBoardRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogForBoardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPartiallyUpdateSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
	updateSprintRequest *UpdateSprintRequest
}

func (r ApiPartiallyUpdateSprintRequest) UpdateSprintRequest(updateSprintRequest UpdateSprintRequest) ApiPartiallyUpdateSprintRequest {
	r.updateSprintRequest = &updateSprintRequest
	return r
}

func (r ApiPartiallyUpdateSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.PartiallyUpdateSprintExecute(r)
}

/*
PartiallyUpdateSprint Partially update sprint

Performs a partial update of a sprint. A partial update means that fields not present in the request JSON will not be updated.

Notes:

 *  For closed sprints, only the name and goal can be updated; changes to other fields will be ignored.
 *  A sprint can be started by updating the state to 'active'. This requires the sprint to be in the 'future' state and have a startDate and endDate set.
 *  A sprint can be completed by updating the state to 'closed'. This action requires the sprint to be in the 'active' state. This sets the completeDate to the time of the request.
 *  Other changes to state are not allowed.
 *  The completeDate field cannot be updated manually.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId The ID of the sprint to update.
 @return ApiPartiallyUpdateSprintRequest
*/
func (a *SprintAPIService) PartiallyUpdateSprint(ctx context.Context, sprintId int64) ApiPartiallyUpdateSprintRequest {
	return ApiPartiallyUpdateSprintRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) PartiallyUpdateSprintExecute(r ApiPartiallyUpdateSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.PartiallyUpdateSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSprintRequest == nil {
		return nil, reportError("updateSprintRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSprintRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetPropertyRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId string
	propertyKey string
	body *interface{}
}

// The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
func (r ApiSetPropertyRequest) Body(body interface{}) ApiSetPropertyRequest {
	r.body = &body
	return r
}

func (r ApiSetPropertyRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SetPropertyExecute(r)
}

/*
SetProperty Set property

Sets the value of the specified sprint's property.

You can use this resource to store a custom data against the sprint identified by the id. The user who stores the data is required to have permissions to modify the sprint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId the ID of the sprint on which the property will be set.
 @param propertyKey the key of the sprint's property. The maximum length of the key is 255 bytes.
 @return ApiSetPropertyRequest
*/
func (a *SprintAPIService) SetProperty(ctx context.Context, sprintId string, propertyKey string) ApiSetPropertyRequest {
	return ApiSetPropertyRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
		propertyKey: propertyKey,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SprintAPIService) SetPropertyExecute(r ApiSetPropertyRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.SetProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/properties/{propertyKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyKey"+"}", url.PathEscape(parameterValueToString(r.propertyKey, "propertyKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwapSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
	swapSprintRequest *SwapSprintRequest
}

func (r ApiSwapSprintRequest) SwapSprintRequest(swapSprintRequest SwapSprintRequest) ApiSwapSprintRequest {
	r.swapSprintRequest = &swapSprintRequest
	return r
}

func (r ApiSwapSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.SwapSprintExecute(r)
}

/*
SwapSprint Swap sprint

Swap the position of the sprint with the second sprint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId The ID of the sprint to swap.
 @return ApiSwapSprintRequest
*/
func (a *SprintAPIService) SwapSprint(ctx context.Context, sprintId int64) ApiSwapSprintRequest {
	return ApiSwapSprintRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) SwapSprintExecute(r ApiSwapSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.SwapSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}/swap"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.swapSprintRequest == nil {
		return nil, reportError("swapSprintRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.swapSprintRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSprintRequest struct {
	ctx context.Context
	ApiService *SprintAPIService
	sprintId int64
	updateSprintRequest *UpdateSprintRequest
}

func (r ApiUpdateSprintRequest) UpdateSprintRequest(updateSprintRequest UpdateSprintRequest) ApiUpdateSprintRequest {
	r.updateSprintRequest = &updateSprintRequest
	return r
}

func (r ApiUpdateSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSprintExecute(r)
}

/*
UpdateSprint Update sprint

Performs a full update of a sprint. A full update means that the result will be exactly the same as the request body. Any fields not present in the request JSON will be set to null.

Notes:

 *  For closed sprints, only the name and goal can be updated; changes to other fields will be ignored.
 *  A sprint can be started by updating the state to 'active'. This requires the sprint to be in the 'future' state and have a startDate and endDate set.
 *  A sprint can be completed by updating the state to 'closed'. This action requires the sprint to be in the 'active' state. This sets the completeDate to the time of the request.
 *  Other changes to state are not allowed.
 *  The completeDate field cannot be updated manually.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sprintId the ID of the sprint to update.
 @return ApiUpdateSprintRequest
*/
func (a *SprintAPIService) UpdateSprint(ctx context.Context, sprintId int64) ApiUpdateSprintRequest {
	return ApiUpdateSprintRequest{
		ApiService: a,
		ctx: ctx,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *SprintAPIService) UpdateSprintExecute(r ApiUpdateSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SprintAPIService.UpdateSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/sprint/{sprintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSprintRequest == nil {
		return nil, reportError("updateSprintRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSprintRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
