/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IssueAPIService IssueAPI service
type IssueAPIService service

type ApiEstimateIssueForBoardRequest struct {
	ctx context.Context
	ApiService *IssueAPIService
	issueIdOrKey string
	estimateIssueForBoardRequest *EstimateIssueForBoardRequest
	boardId *int64
}

// bean that contains value of a new estimation.
func (r ApiEstimateIssueForBoardRequest) EstimateIssueForBoardRequest(estimateIssueForBoardRequest EstimateIssueForBoardRequest) ApiEstimateIssueForBoardRequest {
	r.estimateIssueForBoardRequest = &estimateIssueForBoardRequest
	return r
}

// The ID of the board required to determine which field is used for estimation.
func (r ApiEstimateIssueForBoardRequest) BoardId(boardId int64) ApiEstimateIssueForBoardRequest {
	r.boardId = &boardId
	return r
}

func (r ApiEstimateIssueForBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.EstimateIssueForBoardExecute(r)
}

/*
EstimateIssueForBoard Estimate issue for board

Updates the estimation of the issue. boardId param is required. This param determines which field will be updated on a issue.

Note that this resource changes the estimation field of the issue regardless of appearance the field on the screen.

Original time tracking estimation field accepts estimation in formats like "1w", "2d", "3h", "20m" or number which represent number of minutes. However, internally the field stores and returns the estimation as a number of seconds.

The field used for estimation on the given board can be obtained from [board configuration resource](#agile/1.0/board-getConfiguration). More information about the field are returned by [edit meta resource](#api-rest-api-3-issue-issueIdOrKey-editmeta-get) or [field resource](#api-rest-api-3-field-get).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the requested issue.
 @return ApiEstimateIssueForBoardRequest
*/
func (a *IssueAPIService) EstimateIssueForBoard(ctx context.Context, issueIdOrKey string) ApiEstimateIssueForBoardRequest {
	return ApiEstimateIssueForBoardRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
func (a *IssueAPIService) EstimateIssueForBoardExecute(r ApiEstimateIssueForBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueAPIService.EstimateIssueForBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/issue/{issueIdOrKey}/estimation"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.estimateIssueForBoardRequest == nil {
		return nil, reportError("estimateIssueForBoardRequest is required and must be specified")
	}

	if r.boardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "boardId", r.boardId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.estimateIssueForBoardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIssueRequest struct {
	ctx context.Context
	ApiService *IssueAPIService
	issueIdOrKey string
	fields *[]map[string]interface{}
	expand *string
	updateHistory *bool
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssueRequest) Fields(fields []map[string]interface{}) ApiGetIssueRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetIssueRequest) Expand(expand string) ApiGetIssueRequest {
	r.expand = &expand
	return r
}

// A boolean indicating whether the issue retrieved by this method should be added to the current user&#39;s issue history
func (r ApiGetIssueRequest) UpdateHistory(updateHistory bool) ApiGetIssueRequest {
	r.updateHistory = &updateHistory
	return r
}

func (r ApiGetIssueRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetIssueExecute(r)
}

/*
GetIssue Get issue

Returns a single issue, for a given issue ID or issue key. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the requested issue.
 @return ApiGetIssueRequest
*/
func (a *IssueAPIService) GetIssue(ctx context.Context, issueIdOrKey string) ApiGetIssueRequest {
	return ApiGetIssueRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
func (a *IssueAPIService) GetIssueExecute(r ApiGetIssueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueAPIService.GetIssue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/issue/{issueIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.updateHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateHistory", r.updateHistory, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIssueEstimationForBoardRequest struct {
	ctx context.Context
	ApiService *IssueAPIService
	issueIdOrKey string
	boardId *int64
}

// The ID of the board required to determine which field is used for estimation.
func (r ApiGetIssueEstimationForBoardRequest) BoardId(boardId int64) ApiGetIssueEstimationForBoardRequest {
	r.boardId = &boardId
	return r
}

func (r ApiGetIssueEstimationForBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetIssueEstimationForBoardExecute(r)
}

/*
GetIssueEstimationForBoard Get issue estimation for board

Returns the estimation of the issue and a fieldId of the field that is used for it. `boardId` param is required. This param determines which field will be updated on a issue.

Original time internally stores and returns the estimation as a number of seconds.

The field used for estimation on the given board can be obtained from [board configuration resource](#agile/1.0/board-getConfiguration). More information about the field are returned by [edit meta resource](#api-rest-api-3-issue-getEditIssueMeta) or [field resource](#api-rest-api-3-field-get).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueIdOrKey The ID or key of the requested issue.
 @return ApiGetIssueEstimationForBoardRequest
*/
func (a *IssueAPIService) GetIssueEstimationForBoard(ctx context.Context, issueIdOrKey string) ApiGetIssueEstimationForBoardRequest {
	return ApiGetIssueEstimationForBoardRequest{
		ApiService: a,
		ctx: ctx,
		issueIdOrKey: issueIdOrKey,
	}
}

// Execute executes the request
func (a *IssueAPIService) GetIssueEstimationForBoardExecute(r ApiGetIssueEstimationForBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueAPIService.GetIssueEstimationForBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/issue/{issueIdOrKey}/estimation"
	localVarPath = strings.Replace(localVarPath, "{"+"issueIdOrKey"+"}", url.PathEscape(parameterValueToString(r.issueIdOrKey, "issueIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.boardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "boardId", r.boardId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRankIssuesRequest struct {
	ctx context.Context
	ApiService *IssueAPIService
	moveIssuesToBacklogForBoardRequest *MoveIssuesToBacklogForBoardRequest
}

// bean which contains list of issues to rank and information where it should be ranked.
func (r ApiRankIssuesRequest) MoveIssuesToBacklogForBoardRequest(moveIssuesToBacklogForBoardRequest MoveIssuesToBacklogForBoardRequest) ApiRankIssuesRequest {
	r.moveIssuesToBacklogForBoardRequest = &moveIssuesToBacklogForBoardRequest
	return r
}

func (r ApiRankIssuesRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankIssuesExecute(r)
}

/*
RankIssues Rank issues

Moves (ranks) issues before or after a given issue. At most 50 issues may be ranked at once.

This operation may fail for some issues, although this will be rare. In that case the 207 status code is returned for the whole response and detailed information regarding each issue is available in the response body.

If rankCustomFieldId is not defined, the default rank field will be used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRankIssuesRequest
*/
func (a *IssueAPIService) RankIssues(ctx context.Context) ApiRankIssuesRequest {
	return ApiRankIssuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IssueAPIService) RankIssuesExecute(r ApiRankIssuesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueAPIService.RankIssues")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/issue/rank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogForBoardRequest == nil {
		return nil, reportError("moveIssuesToBacklogForBoardRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogForBoardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
