/*
Jira Software Cloud API

Jira Software Cloud REST API documentation

API version: 1001.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger_software

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BoardAPIService BoardAPI service
type BoardAPIService service

type ApiCreateBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	createBoardRequest *CreateBoardRequest
}

func (r ApiCreateBoardRequest) CreateBoardRequest(createBoardRequest CreateBoardRequest) ApiCreateBoardRequest {
	r.createBoardRequest = &createBoardRequest
	return r
}

func (r ApiCreateBoardRequest) Execute() (*GetAllBoards200ResponseValuesInner, *http.Response, error) {
	return r.ApiService.CreateBoardExecute(r)
}

/*
CreateBoard Create board

Creates a new board. Board name, type and filter ID is required.

 *  `name` \- Must be less than 255 characters.
 *  `type` \- Valid values: scrum, kanban
 *  `filterId` \- ID of a filter that the user has permissions to view. Note, if the user does not have the 'Create shared objects' permission and tries to create a shared board, a private board will be created instead (remember that board sharing depends on the filter sharing).
 *  `location` \- The container that the board will be located in. `location` must include the `type` property (Valid values: project, user). If choosing 'project', then a project must be specified by a `projectKeyOrId` property in `location`. If choosing 'user', the current user is chosen by default. The `projectKeyOrId` property should not be provided.

Note:

 *  If you want to create a new project with an associated board, use the [Jira platform REST API](https://docs.atlassian.com/jira/REST/latest). For more information, see the [Create project](#api-rest-api-3-project-post) method. The `projectTypeKey` for software boards must be 'software' and the `projectTemplateKey` must be either `com.pyxis.greenhopper.jira:gh-kanban-template` or `com.pyxis.greenhopper.jira:gh-scrum-template`.
 *  You can create a filter using the [Jira REST API](https://docs.atlassian.com/jira/REST/latest). For more information, see the [Create filter](#api-rest-api-3-filter-post) method.
 *  If you do not ORDER BY the Rank field for the filter of your board, you will not be able to reorder issues on the board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBoardRequest
*/
func (a *BoardAPIService) CreateBoard(ctx context.Context) ApiCreateBoardRequest {
	return ApiCreateBoardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllBoards200ResponseValuesInner
func (a *BoardAPIService) CreateBoardExecute(r ApiCreateBoardRequest) (*GetAllBoards200ResponseValuesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllBoards200ResponseValuesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.CreateBoard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createBoardRequest == nil {
		return localVarReturnValue, nil, reportError("createBoardRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBoardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
}

func (r ApiDeleteBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBoardExecute(r)
}

/*
DeleteBoard Delete board

Deletes the board. Admin without the view permission can still remove the board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId ID of the board to be deleted
 @return ApiDeleteBoardRequest
*/
func (a *BoardAPIService) DeleteBoard(ctx context.Context, boardId int64) ApiDeleteBoardRequest {
	return ApiDeleteBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) DeleteBoardExecute(r ApiDeleteBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.DeleteBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBoardPropertyRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId string
	propertyKey string
}

func (r ApiDeleteBoardPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBoardPropertyExecute(r)
}

/*
DeleteBoardProperty Delete board property

Removes the property from the board identified by the id. Ths user removing the property is required to have permissions to modify the board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId the id of the board from which the property will be removed.
 @param propertyKey the key of the property to remove.
 @return ApiDeleteBoardPropertyRequest
*/
func (a *BoardAPIService) DeleteBoardProperty(ctx context.Context, boardId string, propertyKey string) ApiDeleteBoardPropertyRequest {
	return ApiDeleteBoardPropertyRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
		propertyKey: propertyKey,
	}
}

// Execute executes the request
func (a *BoardAPIService) DeleteBoardPropertyExecute(r ApiDeleteBoardPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.DeleteBoardProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/properties/{propertyKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyKey"+"}", url.PathEscape(parameterValueToString(r.propertyKey, "propertyKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllBoardsRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	startAt *int64
	maxResults *int32
	type_ *map[string]interface{}
	name *string
	projectKeyOrId *string
	accountIdLocation *string
	projectLocation *string
	includePrivate *bool
	negateLocationFiltering *bool
	orderBy *string
	expand *string
	projectTypeLocation *[]string
	filterId *int64
}

// The starting index of the returned boards. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllBoardsRequest) StartAt(startAt int64) ApiGetAllBoardsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of boards to return per page. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllBoardsRequest) MaxResults(maxResults int32) ApiGetAllBoardsRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results to boards of the specified types. Valid values: scrum, kanban, simple.
func (r ApiGetAllBoardsRequest) Type_(type_ map[string]interface{}) ApiGetAllBoardsRequest {
	r.type_ = &type_
	return r
}

// Filters results to boards that match or partially match the specified name.
func (r ApiGetAllBoardsRequest) Name(name string) ApiGetAllBoardsRequest {
	r.name = &name
	return r
}

// Filters results to boards that are relevant to a project. Relevance means that the jql filter defined in board contains a reference to a project.
func (r ApiGetAllBoardsRequest) ProjectKeyOrId(projectKeyOrId string) ApiGetAllBoardsRequest {
	r.projectKeyOrId = &projectKeyOrId
	return r
}

func (r ApiGetAllBoardsRequest) AccountIdLocation(accountIdLocation string) ApiGetAllBoardsRequest {
	r.accountIdLocation = &accountIdLocation
	return r
}

func (r ApiGetAllBoardsRequest) ProjectLocation(projectLocation string) ApiGetAllBoardsRequest {
	r.projectLocation = &projectLocation
	return r
}

// Appends private boards to the end of the list. The name and type fields are excluded for security reasons.
func (r ApiGetAllBoardsRequest) IncludePrivate(includePrivate bool) ApiGetAllBoardsRequest {
	r.includePrivate = &includePrivate
	return r
}

// If set to true, negate filters used for querying by location. By default false.
func (r ApiGetAllBoardsRequest) NegateLocationFiltering(negateLocationFiltering bool) ApiGetAllBoardsRequest {
	r.negateLocationFiltering = &negateLocationFiltering
	return r
}

// Ordering of the results by a given field. If not provided, values will not be sorted. Valid values: name.
func (r ApiGetAllBoardsRequest) OrderBy(orderBy string) ApiGetAllBoardsRequest {
	r.orderBy = &orderBy
	return r
}

// List of fields to expand for each board. Valid values: admins, permissions.
func (r ApiGetAllBoardsRequest) Expand(expand string) ApiGetAllBoardsRequest {
	r.expand = &expand
	return r
}

// Filters results to boards that are relevant to a project types. Support Jira Software, Jira Service Management. Valid values: software, service\\_desk. By default software.
func (r ApiGetAllBoardsRequest) ProjectTypeLocation(projectTypeLocation []string) ApiGetAllBoardsRequest {
	r.projectTypeLocation = &projectTypeLocation
	return r
}

// Filters results to boards that are relevant to a filter. Not supported for next-gen boards.
func (r ApiGetAllBoardsRequest) FilterId(filterId int64) ApiGetAllBoardsRequest {
	r.filterId = &filterId
	return r
}

func (r ApiGetAllBoardsRequest) Execute() (*GetAllBoards200Response, *http.Response, error) {
	return r.ApiService.GetAllBoardsExecute(r)
}

/*
GetAllBoards Get all boards

Returns all boards. This only includes boards that the user has permission to view.

**Deprecation notice:** The required OAuth 2.0 scopes will be updated on February 15, 2024.

 *  `read:board-scope:jira-software`, `read:project:jira`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllBoardsRequest
*/
func (a *BoardAPIService) GetAllBoards(ctx context.Context) ApiGetAllBoardsRequest {
	return ApiGetAllBoardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllBoards200Response
func (a *BoardAPIService) GetAllBoardsExecute(r ApiGetAllBoardsRequest) (*GetAllBoards200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllBoards200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetAllBoards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", defaultValue, "form", "")
		r.startAt = &defaultValue
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", defaultValue, "form", "")
		r.maxResults = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.projectKeyOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectKeyOrId", r.projectKeyOrId, "form", "")
	}
	if r.accountIdLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdLocation", r.accountIdLocation, "form", "")
	}
	if r.projectLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectLocation", r.projectLocation, "form", "")
	}
	if r.includePrivate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePrivate", r.includePrivate, "form", "")
	}
	if r.negateLocationFiltering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "negateLocationFiltering", r.negateLocationFiltering, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.projectTypeLocation != nil {
		t := *r.projectTypeLocation
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "projectTypeLocation", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "projectTypeLocation", t, "form", "multi")
		}
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllQuickFiltersRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
}

// The starting index of the returned quick filters. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllQuickFiltersRequest) StartAt(startAt int64) ApiGetAllQuickFiltersRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of sprints to return per page. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllQuickFiltersRequest) MaxResults(maxResults int32) ApiGetAllQuickFiltersRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetAllQuickFiltersRequest) Execute() (*GetAllQuickFilters200Response, *http.Response, error) {
	return r.ApiService.GetAllQuickFiltersExecute(r)
}

/*
GetAllQuickFilters Get all quick filters

Returns all quick filters from a board, for a given board ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested quick filters.
 @return ApiGetAllQuickFiltersRequest
*/
func (a *BoardAPIService) GetAllQuickFilters(ctx context.Context, boardId int64) ApiGetAllQuickFiltersRequest {
	return ApiGetAllQuickFiltersRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return GetAllQuickFilters200Response
func (a *BoardAPIService) GetAllQuickFiltersExecute(r ApiGetAllQuickFiltersRequest) (*GetAllQuickFilters200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllQuickFilters200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetAllQuickFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/quickfilter"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllSprintsRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
	state *map[string]interface{}
}

// The starting index of the returned sprints. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllSprintsRequest) StartAt(startAt int64) ApiGetAllSprintsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of sprints to return per page. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllSprintsRequest) MaxResults(maxResults int32) ApiGetAllSprintsRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results to sprints in specified states. Valid values: future, active, closed. You can define multiple states separated by commas, e.g. state&#x3D;active,closed
func (r ApiGetAllSprintsRequest) State(state map[string]interface{}) ApiGetAllSprintsRequest {
	r.state = &state
	return r
}

func (r ApiGetAllSprintsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAllSprintsExecute(r)
}

/*
GetAllSprints Get all sprints

Returns all sprints from a board, for a given board ID. This only includes sprints that the user has permission to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested sprints.
 @return ApiGetAllSprintsRequest
*/
func (a *BoardAPIService) GetAllSprints(ctx context.Context, boardId int64) ApiGetAllSprintsRequest {
	return ApiGetAllSprintsRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetAllSprintsExecute(r ApiGetAllSprintsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetAllSprints")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/sprint"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllVersionsRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
	released *string
}

// The starting index of the returned versions. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllVersionsRequest) StartAt(startAt int64) ApiGetAllVersionsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of versions to return per page. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetAllVersionsRequest) MaxResults(maxResults int32) ApiGetAllVersionsRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results to versions that are either released or unreleased. Valid values: true, false.
func (r ApiGetAllVersionsRequest) Released(released string) ApiGetAllVersionsRequest {
	r.released = &released
	return r
}

func (r ApiGetAllVersionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAllVersionsExecute(r)
}

/*
GetAllVersions Get all versions

Returns all versions from a board, for a given board ID. This only includes versions that the user has permission to view. Note, if the user does not have permission to view the board, no versions will be returned at all. Returned versions are ordered by the name of the project from which they belong and then by sequence defined by user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested versions.
 @return ApiGetAllVersionsRequest
*/
func (a *BoardAPIService) GetAllVersions(ctx context.Context, boardId int64) ApiGetAllVersionsRequest {
	return ApiGetAllVersionsRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetAllVersionsExecute(r ApiGetAllVersionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetAllVersions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/version"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.released != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "released", r.released, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
}

func (r ApiGetBoardRequest) Execute() (*GetAllBoards200ResponseValuesInner, *http.Response, error) {
	return r.ApiService.GetBoardExecute(r)
}

/*
GetBoard Get board

Returns the board for the given board ID. This board will only be returned if the user has permission to view it. Admins without the view permission will see the board as a private one, so will see only a subset of the board's data (board location for instance).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the requested board.
 @return ApiGetBoardRequest
*/
func (a *BoardAPIService) GetBoard(ctx context.Context, boardId int64) ApiGetBoardRequest {
	return ApiGetBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return GetAllBoards200ResponseValuesInner
func (a *BoardAPIService) GetBoardExecute(r ApiGetBoardRequest) (*GetAllBoards200ResponseValuesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllBoards200ResponseValuesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetBoard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoardByFilterIdRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	filterId int64
	startAt *int64
	maxResults *int32
}

// The starting index of the returned boards. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetBoardByFilterIdRequest) StartAt(startAt int64) ApiGetBoardByFilterIdRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of boards to return per page. Default: 50. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetBoardByFilterIdRequest) MaxResults(maxResults int32) ApiGetBoardByFilterIdRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetBoardByFilterIdRequest) Execute() (*GetBoardByFilterId200Response, *http.Response, error) {
	return r.ApiService.GetBoardByFilterIdExecute(r)
}

/*
GetBoardByFilterId Get board by filter id

Returns any boards which use the provided filter id. This method can be executed by users without a valid software license in order to find which boards are using a particular filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filterId Filters results to boards that are relevant to a filter. Not supported for next-gen boards.
 @return ApiGetBoardByFilterIdRequest
*/
func (a *BoardAPIService) GetBoardByFilterId(ctx context.Context, filterId int64) ApiGetBoardByFilterIdRequest {
	return ApiGetBoardByFilterIdRequest{
		ApiService: a,
		ctx: ctx,
		filterId: filterId,
	}
}

// Execute executes the request
//  @return GetBoardByFilterId200Response
func (a *BoardAPIService) GetBoardByFilterIdExecute(r ApiGetBoardByFilterIdRequest) (*GetBoardByFilterId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBoardByFilterId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetBoardByFilterId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/filter/{filterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"filterId"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoardIssuesForEpicRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	epicId int64
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetBoardIssuesForEpicRequest) StartAt(startAt int64) ApiGetBoardIssuesForEpicRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. Default: 50. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetBoardIssuesForEpicRequest) MaxResults(maxResults int32) ApiGetBoardIssuesForEpicRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.
func (r ApiGetBoardIssuesForEpicRequest) Jql(jql string) ApiGetBoardIssuesForEpicRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetBoardIssuesForEpicRequest) ValidateQuery(validateQuery bool) ApiGetBoardIssuesForEpicRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetBoardIssuesForEpicRequest) Fields(fields []map[string]interface{}) ApiGetBoardIssuesForEpicRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetBoardIssuesForEpicRequest) Expand(expand string) ApiGetBoardIssuesForEpicRequest {
	r.expand = &expand
	return r
}

func (r ApiGetBoardIssuesForEpicRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBoardIssuesForEpicExecute(r)
}

/*
GetBoardIssuesForEpic Get board issues for epic

Returns all issues that belong to an epic on the board, for the given epic ID and the board ID. This only includes issues that the user has permission to view. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic. By default, the returned issues are ordered by rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested issues.
 @param epicId The ID of the epic that contains the requested issues.
 @return ApiGetBoardIssuesForEpicRequest
*/
func (a *BoardAPIService) GetBoardIssuesForEpic(ctx context.Context, boardId int64, epicId int64) ApiGetBoardIssuesForEpicRequest {
	return ApiGetBoardIssuesForEpicRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
		epicId: epicId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetBoardIssuesForEpicExecute(r ApiGetBoardIssuesForEpicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetBoardIssuesForEpic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/epic/{epicId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"epicId"+"}", url.PathEscape(parameterValueToString(r.epicId, "epicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBoardIssuesForSprintRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	sprintId int64
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetBoardIssuesForSprintRequest) StartAt(startAt int64) ApiGetBoardIssuesForSprintRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetBoardIssuesForSprintRequest) MaxResults(maxResults int32) ApiGetBoardIssuesForSprintRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.   Note that &#x60;username&#x60; and &#x60;userkey&#x60; can&#39;t be used as search terms for this parameter due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetBoardIssuesForSprintRequest) Jql(jql string) ApiGetBoardIssuesForSprintRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetBoardIssuesForSprintRequest) ValidateQuery(validateQuery bool) ApiGetBoardIssuesForSprintRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetBoardIssuesForSprintRequest) Fields(fields []map[string]interface{}) ApiGetBoardIssuesForSprintRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetBoardIssuesForSprintRequest) Expand(expand string) ApiGetBoardIssuesForSprintRequest {
	r.expand = &expand
	return r
}

func (r ApiGetBoardIssuesForSprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBoardIssuesForSprintExecute(r)
}

/*
GetBoardIssuesForSprint Get board issues for sprint

Get all issues you have access to that belong to the sprint from the board. Issue returned from this resource contains additional fields like: sprint, closedSprints, flagged and epic. Issues are returned ordered by rank. JQL order has higher priority than default rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains requested issues.
 @param sprintId The ID of the sprint that contains requested issues.
 @return ApiGetBoardIssuesForSprintRequest
*/
func (a *BoardAPIService) GetBoardIssuesForSprint(ctx context.Context, boardId int64, sprintId int64) ApiGetBoardIssuesForSprintRequest {
	return ApiGetBoardIssuesForSprintRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
		sprintId: sprintId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetBoardIssuesForSprintExecute(r ApiGetBoardIssuesForSprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetBoardIssuesForSprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/sprint/{sprintId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sprintId"+"}", url.PathEscape(parameterValueToString(r.sprintId, "sprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBoardPropertyRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId string
	propertyKey string
}

func (r ApiGetBoardPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBoardPropertyExecute(r)
}

/*
GetBoardProperty Get board property

Returns the value of the property with a given key from the board identified by the provided id. The user who retrieves the property is required to have permissions to view the board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId the ID of the board from which the property will be returned.
 @param propertyKey the key of the property to return.
 @return ApiGetBoardPropertyRequest
*/
func (a *BoardAPIService) GetBoardProperty(ctx context.Context, boardId string, propertyKey string) ApiGetBoardPropertyRequest {
	return ApiGetBoardPropertyRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
		propertyKey: propertyKey,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetBoardPropertyExecute(r ApiGetBoardPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetBoardProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/properties/{propertyKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyKey"+"}", url.PathEscape(parameterValueToString(r.propertyKey, "propertyKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBoardPropertyKeysRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId string
}

func (r ApiGetBoardPropertyKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBoardPropertyKeysExecute(r)
}

/*
GetBoardPropertyKeys Get board property keys

Returns the keys of all properties for the board identified by the id. The user who retrieves the property keys is required to have permissions to view the board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId the ID of the board from which property keys will be returned.
 @return ApiGetBoardPropertyKeysRequest
*/
func (a *BoardAPIService) GetBoardPropertyKeys(ctx context.Context, boardId string) ApiGetBoardPropertyKeysRequest {
	return ApiGetBoardPropertyKeysRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetBoardPropertyKeysExecute(r ApiGetBoardPropertyKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetBoardPropertyKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConfigurationRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
}

func (r ApiGetConfigurationRequest) Execute() (*GetConfiguration200Response, *http.Response, error) {
	return r.ApiService.GetConfigurationExecute(r)
}

/*
GetConfiguration Get configuration

Get the board configuration. The response contains the following fields:

 *  `id` \- ID of the board.
 *  `name` \- Name of the board.
 *  `filter` \- Reference to the filter used by the given board.
 *  `location` \- Reference to the container that the board is located in. Includes the container type (Valid values: project, user).
 *  `subQuery` (Kanban only) - JQL subquery used by the given board.
 *  `columnConfig` \- The column configuration lists the columns for the board, in the order defined in the column configuration. For each column, it shows the issue status mapping as well as the constraint type (Valid values: none, issueCount, issueCountExclSubs) for the min/max number of issues. Note, the last column with statuses mapped to it is treated as the "Done" column, which means that issues in that column will be marked as already completed.
 *  `estimation` (Scrum only) - Contains information about type of estimation used for the board. Valid values: none, issueCount, field. If the estimation type is "field", the ID and display name of the field used for estimation is also returned. Note, estimates for an issue can be updated by a PUT /rest/api/3/issue/\{issueIdOrKey\} request, however the fields must be on the screen. "timeoriginalestimate" field will never be on the screen, so in order to update it "originalEstimate" in "timetracking" field should be updated.
 *  `ranking` \- Contains information about custom field used for ranking in the given board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board for which configuration is requested.
 @return ApiGetConfigurationRequest
*/
func (a *BoardAPIService) GetConfiguration(ctx context.Context, boardId int64) ApiGetConfigurationRequest {
	return ApiGetConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return GetConfiguration200Response
func (a *BoardAPIService) GetConfigurationExecute(r ApiGetConfigurationRequest) (*GetConfiguration200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConfiguration200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEpicsRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
	done *string
}

// The starting index of the returned epics. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetEpicsRequest) StartAt(startAt int64) ApiGetEpicsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of epics to return per page. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetEpicsRequest) MaxResults(maxResults int32) ApiGetEpicsRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results to epics that are either done or not done. Valid values: true, false.
func (r ApiGetEpicsRequest) Done(done string) ApiGetEpicsRequest {
	r.done = &done
	return r
}

func (r ApiGetEpicsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEpicsExecute(r)
}

/*
GetEpics Get epics

Returns all epics from the board, for the given board ID. This only includes epics that the user has permission to view. Note, if the user does not have permission to view the board, no epics will be returned at all.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested epics.
 @return ApiGetEpicsRequest
*/
func (a *BoardAPIService) GetEpics(ctx context.Context, boardId int64) ApiGetEpicsRequest {
	return ApiGetEpicsRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetEpicsExecute(r ApiGetEpicsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetEpics")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/epic"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.done != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "done", r.done, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFeaturesForBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
}

func (r ApiGetFeaturesForBoardRequest) Execute() (*GetFeaturesForBoard200Response, *http.Response, error) {
	return r.ApiService.GetFeaturesForBoardExecute(r)
}

/*
GetFeaturesForBoard Get features for board



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId
 @return ApiGetFeaturesForBoardRequest
*/
func (a *BoardAPIService) GetFeaturesForBoard(ctx context.Context, boardId int64) ApiGetFeaturesForBoardRequest {
	return ApiGetFeaturesForBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return GetFeaturesForBoard200Response
func (a *BoardAPIService) GetFeaturesForBoardExecute(r ApiGetFeaturesForBoardRequest) (*GetFeaturesForBoard200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFeaturesForBoard200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetFeaturesForBoard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesForBacklogRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetIssuesForBacklogRequest) StartAt(startAt int64) ApiGetIssuesForBacklogRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. Default: 50. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetIssuesForBacklogRequest) MaxResults(maxResults int32) ApiGetIssuesForBacklogRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.   Note that &#x60;username&#x60; and &#x60;userkey&#x60; can&#39;t be used as search terms for this parameter due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetIssuesForBacklogRequest) Jql(jql string) ApiGetIssuesForBacklogRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetIssuesForBacklogRequest) ValidateQuery(validateQuery bool) ApiGetIssuesForBacklogRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssuesForBacklogRequest) Fields(fields []map[string]interface{}) ApiGetIssuesForBacklogRequest {
	r.fields = &fields
	return r
}

// This parameter is currently not used.
func (r ApiGetIssuesForBacklogRequest) Expand(expand string) ApiGetIssuesForBacklogRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssuesForBacklogRequest) Execute() (*SearchResults, *http.Response, error) {
	return r.ApiService.GetIssuesForBacklogExecute(r)
}

/*
GetIssuesForBacklog Get issues for backlog

Returns all issues from the board's backlog, for the given board ID. This only includes issues that the user has permission to view. The backlog contains incomplete issues that are not assigned to any future or active sprint. Note, if the user does not have permission to view the board, no issues will be returned at all. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic. By default, the returned issues are ordered by rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that has the backlog containing the requested issues.
 @return ApiGetIssuesForBacklogRequest
*/
func (a *BoardAPIService) GetIssuesForBacklog(ctx context.Context, boardId int64) ApiGetIssuesForBacklogRequest {
	return ApiGetIssuesForBacklogRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return SearchResults
func (a *BoardAPIService) GetIssuesForBacklogExecute(r ApiGetIssuesForBacklogRequest) (*SearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetIssuesForBacklog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/backlog"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesForBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetIssuesForBoardRequest) StartAt(startAt int64) ApiGetIssuesForBoardRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetIssuesForBoardRequest) MaxResults(maxResults int32) ApiGetIssuesForBoardRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.   Note that &#x60;username&#x60; and &#x60;userkey&#x60; can&#39;t be used as search terms for this parameter due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetIssuesForBoardRequest) Jql(jql string) ApiGetIssuesForBoardRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetIssuesForBoardRequest) ValidateQuery(validateQuery bool) ApiGetIssuesForBoardRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssuesForBoardRequest) Fields(fields []map[string]interface{}) ApiGetIssuesForBoardRequest {
	r.fields = &fields
	return r
}

// This parameter is currently not used.
func (r ApiGetIssuesForBoardRequest) Expand(expand string) ApiGetIssuesForBoardRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssuesForBoardRequest) Execute() (*SearchResults, *http.Response, error) {
	return r.ApiService.GetIssuesForBoardExecute(r)
}

/*
GetIssuesForBoard Get issues for board

Returns all issues from a board, for a given board ID. This only includes issues that the user has permission to view. An issue belongs to the board if its status is mapped to the board's column. Epic issues do not belongs to the scrum boards. Note, if the user does not have permission to view the board, no issues will be returned at all. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic. By default, the returned issues are ordered by rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested issues.
 @return ApiGetIssuesForBoardRequest
*/
func (a *BoardAPIService) GetIssuesForBoard(ctx context.Context, boardId int64) ApiGetIssuesForBoardRequest {
	return ApiGetIssuesForBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return SearchResults
func (a *BoardAPIService) GetIssuesForBoardExecute(r ApiGetIssuesForBoardRequest) (*SearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetIssuesForBoard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesWithoutEpicForBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
	jql *string
	validateQuery *bool
	fields *[]map[string]interface{}
	expand *string
}

// The starting index of the returned issues. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetIssuesWithoutEpicForBoardRequest) StartAt(startAt int64) ApiGetIssuesWithoutEpicForBoardRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of issues to return per page. See the &#39;Pagination&#39; section at the top of this page for more details. Note, the total number of issues returned is limited by the property &#39;jira.search.views.default.max&#39; in your Jira instance. If you exceed this limit, your results will be truncated.
func (r ApiGetIssuesWithoutEpicForBoardRequest) MaxResults(maxResults int32) ApiGetIssuesWithoutEpicForBoardRequest {
	r.maxResults = &maxResults
	return r
}

// Filters results using a JQL query. If you define an order in your JQL query, it will override the default order of the returned issues.   Note that &#x60;username&#x60; and &#x60;userkey&#x60; can&#39;t be used as search terms for this parameter due to privacy reasons. Use &#x60;accountId&#x60; instead.
func (r ApiGetIssuesWithoutEpicForBoardRequest) Jql(jql string) ApiGetIssuesWithoutEpicForBoardRequest {
	r.jql = &jql
	return r
}

// Specifies whether to validate the JQL query or not. Default: true.
func (r ApiGetIssuesWithoutEpicForBoardRequest) ValidateQuery(validateQuery bool) ApiGetIssuesWithoutEpicForBoardRequest {
	r.validateQuery = &validateQuery
	return r
}

// The list of fields to return for each issue. By default, all navigable and Agile fields are returned.
func (r ApiGetIssuesWithoutEpicForBoardRequest) Fields(fields []map[string]interface{}) ApiGetIssuesWithoutEpicForBoardRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of the parameters to expand.
func (r ApiGetIssuesWithoutEpicForBoardRequest) Expand(expand string) ApiGetIssuesWithoutEpicForBoardRequest {
	r.expand = &expand
	return r
}

func (r ApiGetIssuesWithoutEpicForBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetIssuesWithoutEpicForBoardExecute(r)
}

/*
GetIssuesWithoutEpicForBoard Get issues without epic for board

Returns all issues that do not belong to any epic on a board, for a given board ID. This only includes issues that the user has permission to view. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic. By default, the returned issues are ordered by rank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains the requested issues.
 @return ApiGetIssuesWithoutEpicForBoardRequest
*/
func (a *BoardAPIService) GetIssuesWithoutEpicForBoard(ctx context.Context, boardId int64) ApiGetIssuesWithoutEpicForBoardRequest {
	return ApiGetIssuesWithoutEpicForBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetIssuesWithoutEpicForBoardExecute(r ApiGetIssuesWithoutEpicForBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetIssuesWithoutEpicForBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/epic/none/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.jql != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jql", r.jql, "form", "")
	}
	if r.validateQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateQuery", r.validateQuery, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProjectsRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	startAt *int64
	maxResults *int32
}

// The starting index of the returned projects. Base index: 0. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetProjectsRequest) StartAt(startAt int64) ApiGetProjectsRequest {
	r.startAt = &startAt
	return r
}

// The maximum number of projects to return per page. See the &#39;Pagination&#39; section at the top of this page for more details.
func (r ApiGetProjectsRequest) MaxResults(maxResults int32) ApiGetProjectsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetProjectsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetProjectsExecute(r)
}

/*
GetProjects Get projects

Returns all projects that are associated with the board, for the given board ID. If the user does not have permission to view the board, no projects will be returned at all. Returned projects are ordered by the name.

A project is associated with a board if the board filter contains reference the project or there is an issue from the project that belongs to the board.

The board filter contains reference the project only if JQL query guarantees that returned issues will be returned from the project set defined in JQL. For instance the query `project in (ABC, BCD) AND reporter = admin` have reference to ABC and BCD projects but query `project in (ABC, BCD) OR reporter = admin` doesn't have reference to any project.

An issue belongs to the board if its status is mapped to the board's column. Epic issues do not belongs to the scrum boards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains returned projects.
 @return ApiGetProjectsRequest
*/
func (a *BoardAPIService) GetProjects(ctx context.Context, boardId int64) ApiGetProjectsRequest {
	return ApiGetProjectsRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetProjectsExecute(r ApiGetProjectsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetProjects")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/project"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startAt", r.startAt, "form", "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProjectsFullRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
}

func (r ApiGetProjectsFullRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetProjectsFullExecute(r)
}

/*
GetProjectsFull Get projects full

Returns all projects that are statically associated with the board, for the given board ID. Returned projects are ordered by the name.

A project is associated with a board if the board filter contains reference the project.

The board filter contains reference the project only if JQL query guarantees that returned issues will be returned from the project set defined in JQL. For instance the query `project in (ABC, BCD) AND reporter = admin` have reference to ABC and BCD projects but query `project in (ABC, BCD) OR reporter = admin` doesn't have reference to any project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId The ID of the board that contains returned projects.
 @return ApiGetProjectsFullRequest
*/
func (a *BoardAPIService) GetProjectsFull(ctx context.Context, boardId int64) ApiGetProjectsFullRequest {
	return ApiGetProjectsFullRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) GetProjectsFullExecute(r ApiGetProjectsFullRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetProjectsFull")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/project/full"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetQuickFilterRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	quickFilterId int64
}

func (r ApiGetQuickFilterRequest) Execute() (*GetAllQuickFilters200ResponseValuesInner, *http.Response, error) {
	return r.ApiService.GetQuickFilterExecute(r)
}

/*
GetQuickFilter Get quick filter

Returns the quick filter for a given quick filter ID. The quick filter will only be returned if the user can view the board that the quick filter belongs to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId
 @param quickFilterId The ID of the requested quick filter.
 @return ApiGetQuickFilterRequest
*/
func (a *BoardAPIService) GetQuickFilter(ctx context.Context, boardId int64, quickFilterId int64) ApiGetQuickFilterRequest {
	return ApiGetQuickFilterRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
		quickFilterId: quickFilterId,
	}
}

// Execute executes the request
//  @return GetAllQuickFilters200ResponseValuesInner
func (a *BoardAPIService) GetQuickFilterExecute(r ApiGetQuickFilterRequest) (*GetAllQuickFilters200ResponseValuesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllQuickFilters200ResponseValuesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetQuickFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/quickfilter/{quickFilterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quickFilterId"+"}", url.PathEscape(parameterValueToString(r.quickFilterId, "quickFilterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportsForBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
}

func (r ApiGetReportsForBoardRequest) Execute() (*GetReportsForBoard200Response, *http.Response, error) {
	return r.ApiService.GetReportsForBoardExecute(r)
}

/*
GetReportsForBoard Get reports for board



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId
 @return ApiGetReportsForBoardRequest
*/
func (a *BoardAPIService) GetReportsForBoard(ctx context.Context, boardId int64) ApiGetReportsForBoardRequest {
	return ApiGetReportsForBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return GetReportsForBoard200Response
func (a *BoardAPIService) GetReportsForBoardExecute(r ApiGetReportsForBoardRequest) (*GetReportsForBoard200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReportsForBoard200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.GetReportsForBoard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/reports"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveIssuesToBoardRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	moveIssuesToBacklogForBoardRequest *MoveIssuesToBacklogForBoardRequest
}

func (r ApiMoveIssuesToBoardRequest) MoveIssuesToBacklogForBoardRequest(moveIssuesToBacklogForBoardRequest MoveIssuesToBacklogForBoardRequest) ApiMoveIssuesToBoardRequest {
	r.moveIssuesToBacklogForBoardRequest = &moveIssuesToBacklogForBoardRequest
	return r
}

func (r ApiMoveIssuesToBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveIssuesToBoardExecute(r)
}

/*
MoveIssuesToBoard Move issues to board

Move issues from the backog to the board (if they are already in the backlog of that board).  
This operation either moves an issue(s) onto a board from the backlog (by adding it to the issueList for the board) Or transitions the issue(s) to the first column for a kanban board with backlog. At most 50 issues may be moved at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId
 @return ApiMoveIssuesToBoardRequest
*/
func (a *BoardAPIService) MoveIssuesToBoard(ctx context.Context, boardId int64) ApiMoveIssuesToBoardRequest {
	return ApiMoveIssuesToBoardRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
func (a *BoardAPIService) MoveIssuesToBoardExecute(r ApiMoveIssuesToBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.MoveIssuesToBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveIssuesToBacklogForBoardRequest == nil {
		return nil, reportError("moveIssuesToBacklogForBoardRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveIssuesToBacklogForBoardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetBoardPropertyRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId string
	propertyKey string
	body *interface{}
}

// The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
func (r ApiSetBoardPropertyRequest) Body(body interface{}) ApiSetBoardPropertyRequest {
	r.body = &body
	return r
}

func (r ApiSetBoardPropertyRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SetBoardPropertyExecute(r)
}

/*
SetBoardProperty Set board property

Sets the value of the specified board's property.

You can use this resource to store a custom data against the board identified by the id. The user who stores the data is required to have permissions to modify the board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId the ID of the board on which the property will be set.
 @param propertyKey the key of the board's property. The maximum length of the key is 255 bytes.
 @return ApiSetBoardPropertyRequest
*/
func (a *BoardAPIService) SetBoardProperty(ctx context.Context, boardId string, propertyKey string) ApiSetBoardPropertyRequest {
	return ApiSetBoardPropertyRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
		propertyKey: propertyKey,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BoardAPIService) SetBoardPropertyExecute(r ApiSetBoardPropertyRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.SetBoardProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/properties/{propertyKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyKey"+"}", url.PathEscape(parameterValueToString(r.propertyKey, "propertyKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToggleFeaturesRequest struct {
	ctx context.Context
	ApiService *BoardAPIService
	boardId int64
	toggleFeaturesRequest *ToggleFeaturesRequest
}

func (r ApiToggleFeaturesRequest) ToggleFeaturesRequest(toggleFeaturesRequest ToggleFeaturesRequest) ApiToggleFeaturesRequest {
	r.toggleFeaturesRequest = &toggleFeaturesRequest
	return r
}

func (r ApiToggleFeaturesRequest) Execute() (*GetFeaturesForBoard200Response, *http.Response, error) {
	return r.ApiService.ToggleFeaturesExecute(r)
}

/*
ToggleFeatures Toggle features



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boardId
 @return ApiToggleFeaturesRequest
*/
func (a *BoardAPIService) ToggleFeatures(ctx context.Context, boardId int64) ApiToggleFeaturesRequest {
	return ApiToggleFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		boardId: boardId,
	}
}

// Execute executes the request
//  @return GetFeaturesForBoard200Response
func (a *BoardAPIService) ToggleFeaturesExecute(r ApiToggleFeaturesRequest) (*GetFeaturesForBoard200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFeaturesForBoard200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoardAPIService.ToggleFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/agile/1.0/board/{boardId}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"boardId"+"}", url.PathEscape(parameterValueToString(r.boardId, "boardId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toggleFeaturesRequest == nil {
		return localVarReturnValue, nil, reportError("toggleFeaturesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toggleFeaturesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
